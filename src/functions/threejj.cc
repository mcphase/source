/*-----------------------------------------------------------------------------*\
| Matpack special functions - ThreeJSymbolJ() - Wigner 3j symbols    threejj.cc |
|                                                                               |
| Last change: June 5, 1997							|
|                                                                               |
| Matpack Library Release 1.0                                                   |
| Copyright (C) 1991-1997 by Berndt M. Gammel                                   |
|                                                                               |
| Permission to  use, copy, and  distribute  Matpack  in  its entirety  and its |
| documentation  for non-commercial purpose and  without fee is hereby granted, |
| provided that this license information and copyright notice appear unmodified |
| in all copies.  This software is provided 'as is'  without express or implied |
| warranty.  In no event will the author be held liable for any damages arising |
| from the use of this software.                                                |
| Note that distributing Matpack 'bundled' in with any product is considered to |
| be a 'commercial purpose'.                                                    |
| The software may be modified for your own purposes, but modified versions may |
| not be distributed without prior consent of the author.                       |
|                                                                               |
| Read the  COPYRIGHT and  README files in this distribution about registration |
| and installation of Matpack.                                                  |
|                                                                               |
\*-----------------------------------------------------------------------------*/

#include "../../include/mpspecfunp.h"

//-----------------------------------------------------------------------------//
//
// void ThreeJSymbolJ (double l2, double l3, double m2, double m3, 
//                     double &l1min, double &l1max, double *thrcof, int ndim, 
//                     int &errflag)
//
// Evaluate the Wigner 3j symbol 
//
//       f(l1) = (   l1    l2   l3 )
//               ( -m2-m3  m2   m3 )
//
// for all allowed values of l1, the other parameters being held fixed.
//
// Input Arguments:
// ----------------
//
//   double l2 
//   double l3
//   double m2
//   double m3		Parameters in 3j symbol.
//
//   int  ndim 		Declared length of thrcof in calling program.
//
// Output Arguments:
// -----------------
//
//   double &l1min	Smallest allowable l1 in 3j symbol.
//   double &l1max	Largest allowable l1 in 3j symbol.
//   double *thrcof	Set of 3j coefficients generated by evaluating the
//			3j symbol for all allowed values of l1.  
//			thrcof(i) will contain f(l1min+i), 
//			for i = 0, 2, ... , l1max+l1min.
//
//   int &errflag	Error flag.
//                 	errflag=0  No errors.
//                 	errflag=1  Either l2 < abs(m2) or l3 < abs(m3).
//                 	errflag=2  Either l2+abs(m2) or l3+abs(m3) non-integer.
//                 	errflag=3  l1max-l1min not an integer.
//                 	errflag=4  l1max less than l1min.
//                 	errflag=5  ndim less than l1max-l1min+1.
// Description:
// ------------
//
// Although conventionally the parameters of the vector addition
// coefficients satisfy certain restrictions, such as being integers
// or integers plus 1/2, the restrictions imposed on input to this
// subroutine are somewhat weaker. See, for example, Section 27.9 of
// Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
//
// The restrictions imposed by this subroutine are
//
//       1. l2 >= abs(m2) and l3 >= abs(m3)
//       2. l2+abs(m2) and l3+abs(m3) must be integers
//       3. l1max-l1min must be a non-negative integer, where
//          l1max=l2+l3 and l1min=max(abs(l2-l3),abs(m2+m3))
//
// If the conventional restrictions are satisfied, then these
// restrictions are also met.
//
// The user should be cautious in using input parameters that do
// not satisfy the conventional restrictions. For example, the
// the subroutine produces values of
//       f(L1) = ( l1  2.5  5.8)
//               (-0.3 1.5 -1.2)
// for l1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j 
// symbol, set forth on page 1056 of Messiah, is satisfied.
//
// The subroutine generates f(l1min), f(l1min+1), ..., f(l1max)
// where l1min and l1max are defined above. The sequence f(l1) is
// generated by a three-term recurrence algorithm with scaling to
// control overflow. Both backward and forward recurrence are used to
// maintain numerical stability. The two recurrence sequences are
// matched at an interior point and are normalized from the unitary
// property of 3j coefficients and Wigner's phase convention.
//
// The algorithm is suited to applications in which large quantum
// numbers arise, such as in molecular dynamics.
//
// References:
// -----------
//  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
//     of Mathematical Functions with Formulas, Graphs
//     and Mathematical Tables, NBS Applied Mathematics
//     Series 55, June 1964 and subsequent printings.
//  2. Messiah, Albert., Quantum Mechanics, Volume II,
//     North-Holland Publishing Company, 1963.
//  3. Schulten, Klaus and Gordon, Roy G., Exact recursive
//     evaluation of 3j and 6j coefficients for quantum-
//     mechanical coupling of angular momenta, J Math
//     Phys, v 16, no. 10, October 1975, pp. 1961-1970.
//  4. Schulten, Klaus and Gordon, Roy G., Semiclassical
//     approximations to 3j  and 6j coefficients for
//     quantum-mechanical coupling of angular momenta,
//     J Math Phys, v 16, no. 10, October 1975, pp. 1971-1988.
//  5. Schulten, Klaus and Gordon, Roy G., Recursive
//     evaluation of 3j and 6j coefficients, Computer
//     Phys Comm, v 11, 1976, pp. 269-278.
//  6. SLATEC library, category  C19, 
//     double precision algorithm DRC3JJ.F
//     Keywords: 3j coefficients, 3j symbols, Clebsch-Gordan coefficients, 
//               Racah coefficients, vector addition coefficients,
//               Wigner coefficients
//     Author:   Gordon, R. G., Harvard University
//               Schulten, K., Max Planck Institute
//     Revision history  (YYMMDD)
//     750101  DATE WRITTEN
//     880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
//             HUGE and TINY revised to depend on D1MACH.
//     891229  Prologue description rewritten; other prologue sections
//             revised; LMATCH (location of match point for recurrences)
//             removed from argument list; argument errflag changed to serve
//             only as an error flag (previously, in cases without error,
//             it returned the number of scalings); number of error codes
//             increased to provide more precise error information;
//             program comments revised; SLATEC error handler calls
//             introduced to enable printing of error messages to meet
//             SLATEC standards. These changes were done by D. W. Lozier,
//             M. A. McClain and J. M. Smith of the National Institute
//             of Standards and Technology, formerly NBS.
//     910415  Mixed type expressions eliminated; variable C1 initialized; 
//             description of THRCOF expanded. These changes were done by
//             D. W. Lozier.
//  7. Rewritting of the SLATEX algorithm in C++ and adaption to the
//     Matpack C++ Numerics and Graphics Library by Berndt M. Gammel
//     in June 1997.
//
//-----------------------------------------------------------------------------//


void ThreeJSymbolJ (double l2, double l3, double m2, double m3, 
		    double &l1min, double &l1max, double *thrcof, int ndim, 
		    int &errflag)
{
  const double zero = 0.0, eps = 0.01, one = 1.0, two = 2.0, three = 3.0;

  int nfin, nlim, n, index, lstep, nfinp1, nfinp2, nfinp3, nstep2;
  double x, y, denom, cnorm, ratio, a1, a2, c1, c2, l1, m1, x1, x2, x3, 
         y1, y2, y3, oldfac, dv, newfac, sumbac, thresh, a1s, a2s, 
         sumfor, sumuni, sum1, sum2, c1old, sign1, sign2;

  // Parameter adjustments
  --thrcof;

  errflag = 0;

  // "huge" is the square root of one twentieth of the largest floating
  // point number, approximately.
  double huge   = sqrt(DBL_MAX / 20.0),
         srhuge = sqrt(huge),
         tiny   = one / huge,
         srtiny = one / srhuge;

  // lmatch = zero
  m1 = -m2-m3;

  //  Check error conditions 1 and 2.
  if (l2 - abs(m2) + eps < zero || l3 - abs(m3) + eps < zero) {
    errflag = 1;
    Matpack.Error(Mat::ArgumentDomain, "%s: %s", "ThreeJSymbolJ",
		  "l2-abs(m2) or l3-abs(m3) less than zero.");
    return;
  } else if (fmod(l2 + abs(m2) + eps, one) >= eps + eps || 
	     fmod(l3 + abs(m3) + eps, one) >= eps + eps) {
    errflag = 2;
    Matpack.Error(Mat::ArgumentDomain, "%s: %s", "ThreeJSymbolJ",
		  "l2+abs(m2) or l3+abs(m3) not integer.");
    return;
  }

  //  Limits for l1
  l1min = MpMax(abs(l2-l3),abs(m1));
  l1max = l2 + l3;

  //  Check error condition 3.
  if (fmod(l1max - l1min + eps, one) >= eps + eps) {
    errflag = 3;
    Matpack.Error(Mat::ArgumentDomain, "%s: %s", "ThreeJSymbolJ",
		  "l1max-l1min not integer.");
    return;
  }
  if (l1min < l1max - eps) goto L20;
  if (l1min < l1max + eps) goto L10;

  //  Check error condition 4.
  errflag = 4;    
  Matpack.Error(Mat::ArgumentDomain, "%s: %s", "ThreeJSymbolJ",
		"l1min greater than l1max.");
  return;

  //  This is reached in case that l1 can take only one value,
  //  i.e. l1min = l1max

L10:
  // lscale = 0
  thrcof[1] = (odd(int(abs(l2+m2-l3+m3)+eps)) ? -one : one) / sqrt(l1min+l2+l3+one);
  return;

  //  This is reached in case that l1 takes more than one value,
  //  i.e. l1min < l1max.

L20:
  // lscale = 0
  nfin = int(l1max - l1min + one + eps);
  
  //  Check error condition 5.
  if (ndim - nfin < 0) {  
    errflag = 5;
    Matpack.Error(Mat::ArgumentDomain, "%s: %s", "ThreeJSymbolJ",
		  "Dimension of result array for 3j coefficients too small.");
    return;
  }

  //  Starting forward recursion from l1min taking nstep1 steps

  l1 = l1min;
  newfac = 0.0;
  c1 = 0.0;
  thrcof[1] = srtiny;
  sum1 = (l1 + l1 + one) * tiny;

  lstep = 1;

L30:
  ++lstep;
  l1 += one;

  oldfac = newfac;
  a1 = (l1+l2+l3+one) * (l1-l2+l3) * (l1+l2-l3) * (-l1+l2+l3+one);
  a2 = (l1 + m1) * (l1 - m1);
  newfac = sqrt(a1 * a2);
  if (l1 < one + eps)  goto L40;

  dv = -l2 * (l2+one) * m1 + l3 * (l3+one) * m1 + l1 * (l1-one) * (m3-m2);
  denom = (l1 - one) * newfac;
  
  if (lstep - 2 > 0) c1old = abs(c1);
  c1 = -(l1 + l1 - one) * dv / denom;
  goto L50;

  //  If l1 = 1, (l1-1) has to be factored out of dv, hence

L40:
  c1 = -(l1 + l1 - one) * l1 * (m3 - m2) / newfac;

L50:
  if (lstep > 2) goto L60;

  //  if l1 = l1min + 1, the third term in the recursion equation vanishes, 
  //  hence
  x = srtiny * c1;
  thrcof[2] = x;
  sum1 += tiny * (l1 + l1 + one) * c1 * c1;
  if (lstep == nfin) goto L220;
  goto L30;

L60:
  c2 = -l1 * oldfac / denom;

  //  Recursion to the next 3j coefficient X

  x = c1 * thrcof[lstep - 1] + c2 * thrcof[lstep - 2];
  thrcof[lstep] = x;
  sumfor = sum1;
  sum1 += (l1 + l1 + one) * x * x;
  if (lstep == nfin) goto L100;

  //  See if last unnormalized 3j coefficient exceeds srhuge

  if (abs(x) < srhuge) goto L80;

  //  This is reached if last 3j coefficient larger than srhuge,
  //  so that the recursion series thrcof(1), ... , thrcof(lstep)
  //  has to be rescaled to prevent overflow

  // lscale = lscale + 1
  for (int i = 1; i <= lstep; ++i) {
    if (abs(thrcof[i]) < srtiny) thrcof[i] = zero;
    thrcof[i] /= srhuge;
  }
  sum1 /= huge;
  sumfor /= huge;
  x /= srhuge;

  //  As long as abs(c1) is decreasing, the recursion proceeds towards
  //  increasing 3j values and, hence, is numerically stable.  once
  //  an increase of abs(c1) is detected, the recursion direction is
  //  reversed.

L80:
  if (c1old - abs(c1) <= 0.0) goto L100;
  else  goto L30;

  //  Keep three 3j coefficients around lmatch for comparison with
  //  backward recursion.

L100:
  // lmatch = l1 - 1
  x1 = x;
  x2 = thrcof[lstep - 1];
  x3 = thrcof[lstep - 2];
  nstep2 = nfin - lstep + 3;

  //  Starting backward recursion from l1max taking nstep2 steps, so
  //  that forward and backward recursion overlap at three points
  //  l1 = lmatch+1, lmatch, lmatch-1.

  nfinp1 = nfin + 1;
  nfinp2 = nfin + 2;
  nfinp3 = nfin + 3;
  l1 = l1max;
  thrcof[nfin] = srtiny;
  sum2 = tiny * (l1 + l1 + one);

  l1 += two;
  lstep = 1;
L110:
  ++lstep;
  l1 -= one;

  oldfac = newfac;
  a1s = (l1+l2+l3) * (l1-l2+l3-one) * (l1+l2-l3-one) * (-l1+l2+l3+two);
  a2s = (l1+m1-one) * (l1-m1-one);
  newfac = sqrt(a1s * a2s);

  dv = -l2 * (l2+one) * m1 + l3 * (l3+one) * m1 + l1 * (l1-one) * (m3-m2);

  denom = l1 * newfac;
  c1 = -(l1 + l1 - one) * dv / denom;
  if (lstep > 2) goto L120;

  // If l1 = l1max + 1, the third term in the recursion formula vanishes

  y = srtiny * c1;
  thrcof[nfin - 1] = y;
  sumbac = sum2;
  sum2 += tiny * (l1 + l1 - three) * c1 * c1;
  goto L110;

L120:
  c2 = -(l1 - one) * oldfac / denom;

  //  Recursion to the next 3j coefficient y

  y = c1 * thrcof[nfinp2 - lstep] + c2 * thrcof[nfinp3 - lstep];

  if (lstep == nstep2) goto L200;

  thrcof[nfinp1 - lstep] = y;
  sumbac = sum2;
  sum2 += (l1 + l1 - three) * y * y;

  // See if last unnormalized 3j coefficient exceeds SRHUGE

  if (abs(y) < srhuge) goto L110;

  // This is reached if last 3j coefficient larger than srhuge,
  // so that the recursion series thrcof(nfin), ... ,thrcof(nfin-lstep+1) 
  // has to be rescaled to prevent overflow

  // lscale = lscale + 1
  for (int i = 1; i <= lstep; ++i) {
    index = nfin - i + 1;
    if (abs(thrcof[index]) < srtiny) thrcof[index] = zero;
    thrcof[index] /= srhuge;
  }
  sum2 /= huge;
  sumbac /= huge;

  goto L110;

  // The forward recursion 3j coefficients x1, x2, x3 are to be matched
  // with the corresponding backward recursion values y1, y2, y3.

L200:
  y3 = y;
  y2 = thrcof[nfinp2 - lstep];
  y1 = thrcof[nfinp3 - lstep];

  //  Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds
  //  with minimal error.

  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
  nlim = nfin - nstep2 + 1;

  if (abs(ratio) < one) goto L211;

  for (n = 1; n <= nlim; ++n) 
    thrcof[n] = ratio * thrcof[n];
  sumuni = ratio * ratio * sumfor + sumbac;
  goto L230;

L211:
  ++nlim;
  ratio = one / ratio;
  for (n = nlim; n <= nfin; ++n)
    thrcof[n] = ratio * thrcof[n];
  sumuni = sumfor + ratio * ratio * sumbac;
  goto L230;

L220:
  sumuni = sum1;

  //  Normalize 3j coefficients

L230:
  cnorm = one / sqrt(sumuni);

  //  Sign convention for last 3j coefficient determines overall phase

  sign1 = CopySign(one, thrcof[nfin]);
  sign2 = odd(int(abs(l2 + m2 - l3 + m3) + eps)) ? -one : one;
  if (sign1 * sign2 <= 0.0) cnorm = -cnorm;

  if (abs(cnorm) < one) goto L250;

  for (n = 1; n <= nfin; ++n) 
    thrcof[n] = cnorm * thrcof[n];

  return;

L250:
  thresh = tiny / abs(cnorm);
  for (n = 1; n <= nfin; ++n) {
    if (abs(thrcof[n]) < thresh) thrcof[n] = zero;
    thrcof[n] = cnorm * thrcof[n];
  }
} 

//-----------------------------------------------------------------------------//
