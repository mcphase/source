\section{Programs for Specific Tasks in the World of McPhase}\label{addprog}

This section  contains some further programs which do some important manipulations
in magnetism, ...

\begin{description} 

\item [\prg addj\index{addj} file1.j file2.j:] adds exchange parameters of file2.j to the %%@
parameters in
file1.j - output is written to stdout


\item [\prg anisotropy:] program to calculate the magnetic anistropy
\begin{verbatim}
    usage: anisotropy -h 
           anisotropy T H xn yn zn nofsteps so1ion -r sipffilename -B
           anisotropy T H xn yn zn nofsteps ic1ion sipffilename
           anisotropy T H xn yn zn nofsteps icf1ion sipffilename

     -h           : this (help) message
      T           : temperature in Kelvin
      H           : absolute value of the magnetic field
      xn,yn,zn    : direction normal to plane, in which the anisotropy
                    should be calculated ... e.g. if you want to
                    calculate the anisotropy in the xy plane, then
                    enter xn yn zn = 0 0 1
      nofsteps    : number of steps to be calculated 
      so1ion      : use so1ion module
      ic1ion      : use ic1ion module
      sipffilename: filename of single ion parameter file

    output files:

    ./results/anisotropy.out  contains anisotropy information 
\end{verbatim}

\item [\prg cpso1ion 10 100 1 {[options]}: ] calculates the specific heat in the temperature %%@
interval 10-100 K with a step width
of 1 K. Alternatively a comparison to experimental data can be made by {\bf cpso1ion 1 2 %%@
cpexp.dat},
where the temperatures are given in column 1 and the experimental specific heat in column
2 of file cpexp.dat. The calculated specific heat is compared to the experimental data and
a standard deviation {\em sta} is calculated and output is written to stdout.
Other quantities can be calculated using the options: -s  (calculate entropy  (J/molK) instead %%@
of cp),
-f (calculate free energy (J/mol) instead of cp),-u  (calculate magnetic energy (J/mol) instead %%@
of cp),
-z (calculate partition sum instead of cp).
\item[\prg cpic1ion 10 100 1 [options]:] same as {\prg cpso1ion} but for output of program
ic1ion.
					  
\item [\prg epsdebye\index{epsdebye} Tmax dT Tdebye scale [d1 d2 datafile]:]	        
		    calculates the phonon induced strain $\epsilon$ using the debye model
		    according to the following formula:
		    $   \epsilon=S*T*D(\Theta_{D}/T) $
				    with    
		    $D(z)=\frac{3}{z^3}\int_0^z \frac{x^3 dx}{e^x-1}$
                 Range is from zero to Tmax in stepwidths dT
		 unless a datafile is given. 
                 If a  datafile is given, with data column d1 and d2,the strain
                 is calculated for T-values of data column d1 and epsilon
		  is compared to data in column d2 - a standard 
                 deviation sta is calculated as a sum of squared deviations.
                 As output the datafile is given, an additional is column added 
		 containing the calculated strain epsilon. The datafile has to
		 be sorted according to descending T values !!!
                 output is written to stdout.

\item [\prg extendunitcell\index{extendunitcell} n1 n2 n3]program to extend crystallographic %%@
unit cell n 
                times in r1 (or r2,r3) direction, meaning take mcphas.j, mcphas.tst 
                and mcdiff\index{mcdiff}.in and generate an extended description of the unit %%@
cell 
                n1xr1,n2xr2,n3xr3 put result into extend.j, extend.tst and extend.in

\item [\prg fermicol\index{fermicol} col T filename] calculates the Fermifunction from energy in column col.
\begin{description}
\item[col] column containing energy values (eV) relative to EF
 \item[T] temperature (K)
 \item[filename] file name
\end{description}
\item[\prg fitfermi\index{fitfermi} T EF fwhm min max filename] 
fits a (Gaussian convoluted) Fermi function to data in file
\begin{description}
\item[T] Temperature (K)
\item[EF] initial value of Fermi Energy (eV)
\item[fwhm] initial vlaue for resolution (eV) (if less than zero the fwhm is not fitted and set to |fwhm|)
\item[min max] energy range of fit (may be less than range of experimental data points)
\item[filename] filename (col 1 is energy in eV and col 2 intensity)
\end{description}
The fermifunction is defined as
      $ f(E)=b+l(E-EF)+[d+k(E-EF)]/(\exp((E-EF)/kT)+1)$, the function
      $ f(E)$ is convoluted with a Gaussian function of given fwhm
            and the  result is compared to experimental data.

 output:  files can be found in directory results, filename.fit is created with fitted function and parameter values
\item[\prg formfactor\index{formfactor} *.sipf] program to calculate the neutron magnetic formfactor
from the formfactor coefficients in the single ion parameter file *.sipf. If a radial wave function is given in *.sipf
then the formfactorand the expectation values of the spherical Bessel functions  are evaluated by integration
with this radial wave function (see appendix \ref{ffacts}).
\item [\prg jjj2j:] transforms file of {\prg mcphas.jjj} format to {\prg %%@
mcphas.j\index{mcphas.j}} format
- output is written to stdout

\item[\prg makenn 23.3:] Program to calculate neighbors of atoms given a crystal structure.
Note that in order to use {\prg makenn\index{makenn}} you have to set up a 
working {\prg mcphas.j\index{mcphas.j}} file with the crystal structure. 
The program {\prg makenn\index{makenn}} takes {\prg mcphas.j\index{mcphas.j}} and
creates all neighbours within a sphere of distance 23.3\AA, for every neighbour the classical
dipole interaction is calculated and is stored in file {\prg makenn.j}. If the exchange %%@
parameters 
(and neighbour positions) are not known for your system, you can use this module 
to generate a list of nearest neighbours and exchange parameters. Currently implemented 
 are not only dipolar interactions, but also exchange interactions via the Bethe-Slater 
curve or the RKKY model. 
\begin{description}
\item[option {\prg -rkky A(meV) kf(1/A)}] calculates the rkky interaction according to $J(R)=A %%@
cos(2 k_f R)/(2 k_f R)^3$
\item[option {\prg -rkky3d A(meV) ka(1/A) kb(1/A) kc(1/A)}] calculates the rkky interaction %%@
according to $J(R)=A cos(2 \kappa)/(2 \kappa)^3$ with $\kappa^2=k_a^2 R_a^2 + k_b^2 R_b^2 + %%@
k_c^2 R_c^2$
\item[option {\prg -rkkz A(meV) kf(1/A)}] calculates the rkky interaction according to $J(R)=A %%@
(sin(2 k_f R)- 2 k_f R cos(2 k_f R))/(2 k_f R)^4$
\item[option {\prg -rkkz3d A(meV) ka(1/A) kb(1/A) kc(1/A)}] calculates the rkky interaction %%@
according to $J(R)=A (sin(2 \kappa)- 2 \kappa cos(2 \kappa))/(2 \kappa)^4$ with $\kappa^2=k_a^2 %%@
R_a^2 + k_b^2 R_b^2 + k_c^2 R_c^2$
\item[option {\prg -kaneyoshi A(meV) D(A) alpha}] calculates the Kaneyoshi parametrisation for %%@
the Bethe-Slater
                               curve: $J(R)= A [-(R/D)^2+(R/D)^4]exp[-\alpha (R/D)^2]$  with $D$ %%@
corresponding
                               to the orbital radius
\item[option {\prg -kaneyoshi3d A(meV) Da(A) Db(A) Dc(A) alpha}] calculates the Kaneyoshi %%@
parametrisation for the Bethe-Slater
                               curve: $J(R)= A [-\rho^2+\rho^4]exp[-\alpha \rho^2]$  with %%@
$\rho^2=R_a^2/D_a^2+R_b^2/D_b^2+R_c^2/D_c^2$
\item[option {\prg -d}] puts to the last column the distance of the neighbours (A)
\end{description}
The neigbours of each atom are also stored in seperate files
{\prg results\/makenn.a*.pc}, which can be used with the program {\prg pointc} to evaluate
the pointcharge model and calculate crystal field paramaters.

\item [\prg pointc\index{pointc} Ce3+ 0.2 4 1 5.3]
              calculates Crystal field Parameters from Point Charges  
                 ... meaning calculate Stevens Parameters Blms 
                                  and Wybourne Parameters Llms
                 for one point charge of +0.2$|e|$ in distance
                 x=4 \AA y=1 \AA z=5.3 \AA from a Ce$^{3+}$ ion.
                Alternative Usage: pointc\index{pointc} Ce3+ filename
                 ... meaning read several charges+coordinates from file,
                 file format: column 1=charge, column 2-4 = x y z coordinate  (note,
				 ({\prg makenn} creates useful files for this option from the crystal %%@
structure).
                results are written to stdout (including radial matrix elements and Stevens %%@
factors)

                Note: if an ion is not implemented, it's parameters can be 
                      entered in a single ion property file and pointc\index{pointc} is
                      started as 
                        pointc\index{pointc} file.sipf 0.2 4 1 5.3

                      the single ion property file must then contain the following
                      information (\# denotes comments):
\begin{verbatim}
      #the name of the ion
      IONTYPE=Ce3+
      #stevens parameters (optional, necessary for output of Blm)
      ALPHA=-0.0571429
      BETA=0.00634921
      GAMMA=0
      # the radial matrix elements RN=<r^N> in units of a0^N (a0=0.5292 A)
      R2=1.309
      R4=3.964
      R6=23.31
      # alternatively the radial wave function can be given:
      # radial wave function parameters R_Np,XIp(r)= r^(Np-1) . exp(-xi r) . (2 XIp)^(Np+0.5) / %%@
sqrt(2Np!)  
      # values tabulated in clementi & roetti Atomic data and nuclear data tables 14 (1974) %%@
177-478
      # Co2+ is isoelectronic to Fe+, looking at page  422 of Clemente & Roetti 
      # the 3D radial wave function is expanded as R(r)=sum_p C_p R_Np,XIp(r)
      N1=3 XI1=4.95296 C1=0.36301 
      N2=3 XI2=12.2963 C2=0.02707 
      N3=3 XI3=7.03565 C3=0.14777
      N4=3 XI4=2.74850 C4=0.49771 
      N5=3 XI5=1.69027 C5=0.11388
      # if the above parameters are given the radial wave function is output to file %%@
radwavfun.dat                 
\end{verbatim}                      
\item[\prg radwavfunc\index{radwavfunc} file.sipf:] program to evaluate the radial wave function
given by th parametrisation in file.sipf.
\item [\prg powdercell2j\index{powdercell2j} file:]     used to create mcphas.j type file from %%@
output of powdercell,output is written to mcphas.j.  Example of input file:
\begin{verbatim}
  No   name       crystal coordinates          cartesian coordinates
                 x        y        z           x        y        z
  ------------------------------------------------------------------
  1     Sr1    0.3644   0.0000   0.2500     1.0962  -4.1497  -2.7991
  ...
  \end{verbatim}
\item [\prg rotateBlm\index{rotateBlm}]
  \begin{verbatim}
    Rotates a set of  crystal field  parameters for  Stevens equivalent
    operators by an azimuthal angle fi about the original z axis and
    a polar angle theta about the new y axis. A right hand axis system is assumed
    and a positive rotation is one which advances a right-hand screw in a
    positive direction along the axis.

    The calculations are  done by means of matrix  multiplication based on
    the method of Buckmaster (phys. stat. sol. a, vol 13,  pp 9, 1972) and
    Rudowicz (J. Phys: Solid State Phys., vol 18, pp 1415, 1985).   

    usage: $0 [-h] [--help] 
              [-i input_file] [--input input_file]
	      [-o output_file] [--output output_file]
              [-v] [--verbose] [-th theta] [-fi fi] [CF parameters]

          
     -h          : this (help) message
     -i in_file  : input CF parameters file in cfield or mcphase formats
     -o out_file : output CF parameters file in mcphase format
     -v          : verbose mode. Will print out input parameters as read.
     -th	 : polar angle theta in degrees
     -fi         : azimuthal angle fi in degrees

    if -i is omitted, the program will  assume the input CF parameters are
          given on the command line in the format: Bkq=x.xx,Bkq=x.xx, etc.
          e.g. $0 B20=0.21,B40=0.0005,B60=0.051,B66=0.626
    negative q parameters such as B_2^{-2},  are specified as:  B22S, with 
          an 'S' at the end, as per the McPhase convention.
    you may also  specify the ion type by a dding another  parameter after
          the CF parameters: e.g. $0 B20=0.21,B40=0.5 Pr3+
    if -o is omitted, the program prints the parameters to standard output.
  \end{verbatim}
\item[\prg   setup\_jqfit\index{setup\_jqfit}[-h] [--help] h k l:] program to setup a fit of exchange parameters in order to reproduce an experimental propagation vector.
\begin{verbatim}
     -h          : print help message
      hkl        : Miller indices of propagation vector

    required input files:

    mcphas.j (+ single ion paramter files)
                 :  structural information including all magnetic atoms

    output files:

    mcdisp.par   :  contains propagation vector and list of other hkl to
                    be probed
    mcdisp.mf    :  required input file for mcdisp
    calcsta      :  required input file for simannfit and searchspace
    calcsta.pl.forfit: file with fitparameters for Bethe slater, RKKY fits
    fit.bat      :  batch to start the fit

   
\end{verbatim}

 After running this program you can start immediately a fit of exchange
    parameters. Edit {\prg calcsta.pl.forfit} and {\prg fit.bat} to fine tune the fit 
    according to your needs.
    During fitting a value of sta $< 1$~ indicates, that the maximum of $J(Q)$ is
    at the propagation vector tau. How much it is below one depends on the
    magnitude of $J(Q)$ for the competing wavevectors in the list in{\prg  mcdisp.par}.

\item [\prg setup\_mcdiff\_in\index{setup\_mcdiff\_in}  T Ha Hb Hc:] program
 to setup {\prg mcdiff.in} with information on spinconfiguration
                    to be used by program {\prg mcdiff\index{mcdiff}}. Note, you must
                    have done a {\prg mcphas\index{mcphas}} calculation to stabilise
                    a magnetic structure at the desired Temperature/Field.
                  { \prg   setup\_mcdiff\_in} reads the results of this calculation
                    from {\prg results/mcphas.mf} and generates an input file
                    {\prg mcdiff.in}

\begin{verbatim}
     -h          : this (help) message
      T          : Temperature (K)
      Ha,Hb,Hc   : Magnetic Field (T)

    required input files:

    results/mcphas.sps
                 :  result of a mcphas calculation

    output files:

    mcdiff.in    :  required input file for mcdiff

    - after running this program you can start mcdiff to do the calculation
      magnetic diffraction pattern
\end{verbatim}
\item [ \prg   setup\_mcdisp\_mf \index{setup\_mcdisp\_mf} T Ha Hb Hc:] program to setup{\prg mcdisp.mf} with information on meanfields
                    to be used by program {\prg mcdisp\index{mcdisp}}. Note, you must
                    have done a {\prg mcphas\index{mcphas}} calculation to stabilise
                    a magnetic structure at the desired Temperature/Field.
                    {\prg   setup\_mcdisp\_mf} reads the results of this calculation
                    from {\prg  results/mcphas.mf} and puts the meanfields into
                    {\prg mcdisp.mf}.


\begin{verbatim}
     -h          : this (help) message
      T          : Temperature (K)
      Ha,Hb,Hc   : Magnetic Field (T)

    required input files:

    results/mcphas.mf
                 :  result of a mcphas calculation

    output files:

    mcdisp.mf    :  required input file for mcdisp

    - after running this program you can start mcdisp to do the calculation
      of dispersion of excitations or diffuse scattering
\end{verbatim}
\item[\prg   setup\_mcphasjforfit\index{setup\_mcphasjforfit}  [-h]:] program to setup a fit of exchange parameters by   creating mcphas.j.forfit from mcphas.j
                    
\begin{verbatim}
     -h          : print help message

    required input files:

    mcphas.j (+ single ion parameter files)
                 :  structural information including all magnetic atoms

    output files:

    mcphas.j.forfit  : all interaction parameters are substituted
                       with parJxxx[0.0,-1e0,1e0,0,1e-6]

    - after running this program you must setup a file calcsta 
      to calculate the standard deviation and then you can start
      a fit by simannfit or searchspace
\end{verbatim}\index{simannfit}\index{searchspace}
\item [\prg singleion\index{singleion} [option] T[K] Hexta[T] Hextb[T] Hextc[T] Hxc1 Hxc2 Hxc3 ... Hxcnofcomponents]
 single ion  - display single ion expectations values $<Ia>, <Ib> $... and transition energies.
\begin{verbatim} 
           Hext ..... external field in Tesla 
           Hxc... exchange (molecular) field in meV   
\end{verbatim}
{\prg singleion} reads {\prg mcphas.j} and the singleion parameter files quoted therein
and calculatesenergies, eigenstates, expectation values $<I>$ for the given
temperature, external magnetic field Hext and exchange field Hxc (the
interaction constants given in mcphas.j are ignored).

for each single ion property file the following files are generated:
\begin{verbatim}
   results/file.sipf.levels.cef .. energy levels and eigenstates and <I>
   results/file.sipf.trs ......... transition energies,matrix elements
                                   and (powder) neutron intensities
   results/_file.sipf    ......... parameters as read by singleion

options: -nt ......... by default only 5 transition energies are output,
                       if you want more, start e.g. with 
                       option -nt 7 to output 7 transition energies
         -pinit 0.1 .. consider only transitions with population of initial state > 0.1
         -ninit 3  ... consider only transitions from the 3 lowest eigenstates
         -maxE 30  ... consider only transitions with energy lower than 30 meV
         -r ion.sipf . do not read mcphas-j but only the single ion
                       parameter file ion.sipf
         -M  ......... calculate expectation values and transition matrix
                       elements for magnetic moment M instead of I
         -S  ......... calculate expectation values and transition matrix
                       elements for spin S
         -L  ......... calculate expectation values and transition matrix
                       elements for orbital momentum L

note: for calculating T or H dependencies you can put single ion in a loop
       and pipe the result into a file

  .... linux:   for B in $(seq 0 0.1 14); do singleion 2 $B 0 0 0 0 0; done > results/fielddep.dat

  .... windows command line: for /L %B in (0,1,14)  do singleion 2 %B 0 0 0 0 0 >> results\fielddep.dat

  .... windows batch file (needed for noninteger numbers):
          @echo off && setlocal ENABLEDELAYEDEXPANSION
          for /L %%I in (0,2,140) do ( set /A W=%%I/10 && set /A "f = %%I %% 10"
          set B=!w!.!f!
          @echo on && singleion 2 0 0 !B! 0 0 0 && @echo off )
          endlocal && @echo on 
\end{verbatim}      
\end{description} 

\section{Programs for Manipulation of Columns and Lines in Data Files}

Datafiles usually contain columns of numbers, for example:

\begin{verbatim}
# T(K) mu0H(T)  M(mb/T)  [comment lines start with '#' ]
1      1      0.9
2      1      0.6
3      1      0.4
4      1      0.3
5      1      0.25
\end{verbatim}

The following programs manipulate such data files, for example
the program {\prg delcol} deletes a column from a data file,
some general features are:
\begin{itemize}
\item data files are overwritten 
\item multiple files may be handled by one command, e.g. {\prg delcol 4 *.dat} deletes column 4
in all 
files ending with .dat
\item arguments may contain mathematical expressions, e.g. 
\begin{description}
\item{\prg shifttcol 3x2+27 2xx4 data.dat} \dots adds to each number in column 33 in file data.dat the number $2^4=8$. 
\item{\prg factcol 2 sin(3.1415/2) data.dat} \dots multiplies column 2 in file data.dat with   sin(3.1415/2)
,i.e. with 0.999999989
\end{description}
\end{itemize}

\begin{description}
\item [\prg acoscol\index{acoscol} col{[ecolerr]} file:] calculates arccosine of a column arccos(col) 
\item [\prg add\index{add} colx1 coly1{[ecoly1err]} file1 colx2 coly2{[ecoly1err]} file2:] 
   program to add functions y1(x1) with (optional) y1err and y2(x2) with (optional y2err)
       taken from data file1 and data file2

\begin{description}
 \item [input:]
 \item[ file1, file2]         filennames
 \item [colx, coly, colyerr]  columns containing x and y=f(x) and yerror values
\item[  output:]
\item[  file1]            contains in coly1=coly1+f2(colx1)
                   and in   coly1err=sqrt[coly1err$^2$+f2err(colx1)$^2$]
                   f2(colx1) is calculated by linear
                   interpolation
                   f2(colx1)=
                   (colx1-colx2(n)*(coly2(n+1)-coly2(n))/(colx2(n+1)-colx2(n))
                   f2err(colx1)=
                   (colx1-colx2(n)*(coly2err(n+1)-coly2err(n))/(colx2(n+1)-colx2(n))
\end{description}
  note:            colx2 has to be sorted in file2
\item [\prg addcol\index{addcol}  colx{[ecolxerr]} coly{[ecolyerr]} file:] adds column x and column y of file, result is %%@
stored in col y
Optional - error is added using the error columns colxerr and colyerr
by colyerr=sqrt(colxerr*colxerr+colyerr*colyerr)
\item [\prg asincol\index{asincol} col const file:] calculates arcsine of a column arcsine(col) 
\item [\prg atancol\index{atancol} col const file:] calculates arctangens of a column %%@
arctan(col) 
\item [\prg chi2\index{chi2} col1 col2 col3 *.*] is used to calculate the 
 chi-squared from 3 columns in a file: if col1, col2 and col3 are calculation, 
 experiment and experimental error, respectively, then
  chisquared is defined as $\chi^2=\frac{1}{n}\sum_{i=1}^n \frac{({\rm col2}_i-{\rm %%@
col1}_i)^2}{{\rm col3_i}^2}$. For each datapoint the program outputs a line
{\em sta=} deviation$^2$  (experimental error)$^2$ to stdout. This may be 
used directly for generating useful input for fitting in {\prg simannfit}\index{simannfit}.
\item [\prg comment l1 l2 file:] comments all lines from l1 and l2  (with \#) in a file
\item [\prg compare file1 file2:] used to compare data file1 and data file2
                all columns and rows are compared and a standard deviation
                is calculated according to sum\_i (file1\_i - file2\_i)\^2
                this standard deviation is output to stdout, e.g. as sta=143.3
\item [\prg convolute\index{convolute} c1 c2 file cx cy convfuncfile [d1 d2 datafile]:] %%@
convolutes data given as column c1 vs column
                       c2 in file (data pairs $x_i,y_i$) with the convolution function given in %%@
column cx vs cy
		        of convfuncfile (function $c(x)$)
		       Range and step width of output file is determined from range and step 
		        of convfuncfile  unless a datafile is given. If a datafile is given, 
		     with data column d1 and d2, the result of the convolution is
		     calculated for x-values of data column d1 and $f(x)$ is compared to
		     data in column d2 - a standard deviation sta is calculated as
		     sum of squared deviations.Values out of range of convfile are assumed to be zero,
			convfile has to be sorted according to ascending x.
			Formula: $f(x)=\sum_i y_i c(x-x_i)$ , 
		       output is written to stdout. 
\item [\prg convolute2d\index{convolute2d} c1 c2 c3 file cx cy cz convfuncfile minx maxx Nx miny maxy Ny:] 
convolutes a 2 dimensional function data given as column c3(c1,c2) in file (data tripls $x_i,y_i, z_i$) with the convolution function given in column cx vs cy vs cz
		        of convfuncfile (function $c(x,y)$)
		       Range and number of points of output file is determined from minx maxx Nx and 
                        miny, maxy Ny.
			Formula: $f(x,y)=\sum_i z_i c(x-x_i,y-y_i)$ . In the program the contribution to
                        the sum is evaluated for a discrete triplet cx cy cz of the convolution function, the 
                        resulting x,y will not correspond to a point on the grid defined by minx, max Nx, miny,maxy Ny -
                        therefore the contribution is distributed (according to distance) onto the neighbouring grid
                       points.
		       output is written to stdout. 
\item [\prg coscol\index{coscol} col const file:] calculates cosinus of a column cos(col) 
\item [\prg delcol\index{delcol} col file:] deletes column col in file
\item [\prg delcols\index{delcols} col n file:] deletes column col several (n) times in file
\item [\prg delcomments *.*] removes every comment line (starting with \#) from a file and %%@
prints the removed lines to screen
\item [\prg delline\index{delline} l1 l2 file:] deletes lines l1 to l2  in file
\item [\prg delnthline n file]  remove every nth line (n$>$2) in file
\item [\prg dif\index{dif} colx coly n *.*:] used to calculate d(coly)/d(colx) with %%@
differentiation averaging n points
\item [\prg display\index{display} 5[e7] 6[e8]  ./results/mcdisp.qei {[colx coly file2]}] displays a graphic on screen as xy %%@
graph
with column 5 as x axis and columns 6 as y axis. By default graphic is a line graph.
However, if error columns (in the example x error column is 7 and y error column is 8)
are given, then symbols with x and y error bars are shown. Several files
can be plotted in the same graph by extending the commandline. If the contents of a file
changes, the plot is automatically updated.
\item [\prg displaybubbles\index{displaybubbles}  5 6 8 ./results/mcdisp.qei] works similar as %%@
display, however
a third column is given and the radius of the symbols varied according to the data in 
this column.
\item [\prg displaycontour\index{displaycontour} 5 6 8 ./results/mcdisp.dsigma.tot] produces a %%@
graphical
display\index{display} of a 3 dimensional dataset as a colour and/or contour plot. Here '5 6 8' 
denote the x,y and z column in file {\prg ./results/mcdisp.dsigma.tot}, which should
be plotted. Figure~\ref{ho2ti2o7diffuse} shows an sample output of this program.
\item [\prg displaytext\index{displaytext} ./results/mcphas.hkl] monitors the file mcphas.hkl in %%@
a text window
on screen.
\item [\prg expcol\index{expcol} col const file:] calculates exponent of a column exp(col) 
\item [\prg factcol\index{factcol} col{[ecolerr]} const file:] multiplies col with a constant in file,
a error colmn may be given and is also multiplied by the absvalue of the constant.
\item [\prg fform\index{fform} col1 col2 format file:] reformats numbers in col1 to col2 in file %%@
with
             a number format given by format. Format is a number format string according
             to c conventions, for example 8.4f or 4.4g  ...             
\item [\prg fillcol  col expression *.*\index{fillcol}]  used to fill column with numbers in data file
\begin{verbatim}
 col       ....   column
 expression ...   e.g. 'tan(c1x7.52)+c2'
                  here c1,c2,.. refer to column 1,2,...
                  operations are multiplication (x), division(/)
                  addition (+), subtraction(-), power (xx)
                  trigonometric functions tan,cos,sin, asin,atan,acos
                  exp,(natural) log
 *.*       ....   filenname
\end{verbatim}
\item [\prg fitcol coldata prog col parprog1 parprog2 ... {[]} in filename:]
simple fitting program for data in coldata.
\begin{verbatim}
               []=[and prog col parprog1 parprog2 ... [and ...]]

          coldata ...... column number of data column to be fitted
          prog    ...... program name, e.g. shiftcol
          col     ...... column to which prog should be applied
          parprog1 ..... parameter of the program prog, which should be fitted
          filename... filename

    in order to fit data in column coldata, prog is run many times on
    the column col with varying parameter set parprog1 ..., the result
    is scaled to fit best the experimental data. If several programs
    are combined with option 'and' then the best linear combination of the
    results is calculated by linear regression to fit coldata.

    Starting values for the parameters parprog are taken from the
    commandline. initial Stepwidths are chosen 10percent of parameter value, or may
    be given by adding them to the parameter with an 's', e.g. 100.3s0.1
    If a parameter should not be fitted and kept fix, add an 'f', e.g. 100.3f

    output: - files can be found in directory results
            - filename.fit is created with fitted function and parameter values

    examples:
    1) to fit a gaussian to column 2 in datafile expdat (with xvalues in column 1)
    with starting values 132.3, 0.5 and 10 for position, fwhm and area, respectively:

    fitcol 2 gausscol 1 132.3 0.5 10 in exp.dat


    2) to do the same fit but with a background create a column 3, fill it
       with constant values and use echo as a fake column manipulation program
      doing nothing.

   newcol 3 -c 1.0 exp.dat
   fitcol 2 gausscol 1 132.3 0.5 10 and rem 3 in exp.dat

   3) to do the same with a linear background, put into a column 4 the x values

   newcol 4 -c 4.0 exp.dat
   fitcol 2 gausscol 1 132.3 0.5 10 and rem 3 and rem 4 in exp.dat

   4) to fit two gaussians with fixed fwhm and stepping in position initially
    only with 0.1

   fitcol 2 gausscol 1 132.3s0.1 0.5f 10 and  gausscol 1 100.3s0.1 0.5f 10 and rem 3 and rem 4 in exp.dat
\end{verbatim}

\item[\prg gausscol\index{gausscol} col position fwhm area *.*:] calculate a
gaussian from the x values given in column col.

The formula for a gaussian is:
$\sigma={\rm fwhm}/\sqrt{8*log(2)}$,
${\rm gauss}(x)=\frac{{\rm area} exp(-(x-{\rm position})^2/2 \sigma^2)}{\sqrt{2*\pi}\sigma}$

\item[\prg getvalue\index{getvalue} colx coly xvalue dx filename]
program to get the y-value of a function by averaging
 over an interval xvalue+-dx,
 note: colx has to be sorted
\begin{verbatim}
 output: the y-value is written to stdout and environment variable MCPHASE_YVALUE
         1/y-value is written to stdout MCPHASE_YVALUE_INVERSE
         standarddeviation to stdaout and MCPHASE_STA
\end{verbatim}
\item[\prg getvariable\index{getvariable} variablename filename]
 program to get the value of a variable from a file 
  (e.g. somewhere in a file there is 
   a statement T=4.3 and you want to get out this 4.3)
\begin{verbatim}
 output: the variable value is written to stdout and environment variable 
         MCPHASE_GETVARIABLE_VALUE, the name is stored in 
         MCPHASE_GETVARIABLE_NAME
        mind lines starting with # are ignored (unless these start with #!)
\end{verbatim}
\item[\prg histcol\index{histcol} col {[stepwidth|-n steps]} *.*:] generates a histogram of
a column in a data file and stores it in histcol.out. stepwidth is the 
stepwidth of the histogram points. Alternatively the number of
steps in the histogram may be given by e.g. {\prg -n 100}.
\item[\prg int\index{int} {[-m] }colx coly *.*:]
 program  to integrate columnx vs columny=f(x), integration is done 
point by point, the result goes to the data file, the total integral 
INT=$\int f(x)dx$ is printed to stdout and set to the 
 environment variable MCPHASE\_INT.
 option -m: n-th moments\index{moments of a distribution} are calculated according to $\mu_1=\int x f(x)dx$/INT, $\mu_n=\int (x-\mu_1)^n f(x)dx$/INT.
The results go to stdout and environment variables MCPHASE\_INT\_MU\_1,
  MCPHASE\_INT\_MU\_2,MCPHASE\_INT\_MU\_3 ... are set.

\item [\prg linreg\index{linreg} col n file:] calculates linear regression of n columns in file
\begin{verbatim}
          col     ...... column containing y_k values followed by
          n       ...... n columns containing x_ik (i=1 to n)
	  filename... filename

    the program calculates the linear regression, i.e. the best values
    of coefficients ai such that y_k~sum_i a_i*x_ik for every data line k
    in the file. The n linear regression equations solved to determin a_i
    are (i,j=1 ...n):

     sum_k x_jk y_k = sum_i a_i (sum_k x_ik * x_jk)

   Output: - sdtoud: best coefficients a_i  and standard deviation
             sta=sum_k (y_k-sum_i a_i*x_ik)^2
           - file: new column col+n+1 contining sum_i a_i*x_ik
\end{verbatim}

\item [\prg lorentzcol\index{lorentzcol} col position fwhm area:] calculate a lorentzian from
a column with x values, the formula for a Lorentz curve is: 
${\rm lorentz}(x)=\frac{1.0}{\pi{\rm fwhm}(1.0+(x-{\rm position})^2/fwhm^2)}$
\item [\prg multcol\index{multcol}  colx coly file:] multiplies column x and column y of file, %%@
result is stored in col y
\item [\prg newcol\index{newcol} col {[options]} file:] creates a new column col in file containing the line numbe. option: -c 12.3  ... instead of line number put constant 12.3 into the new column
\item [\prg newcols\index{newcols} col n {[options]} file:] creates n new columns from column col
 in file. New columns are inserted after column col and contain the same data as column col.
 options: -c 12.3 ...  put constant 12.3 into the new columns, -n ... put line number into the new column.
\item [\prg newline\index{newline} n text file:] creates a new line number n  in file containing %%@
the text 
\item [\prg potcol\index{potcol} col const file:]  col=col$^{\rm const}$ in file
\item [\prg range\index{range} col min max file:] deletes (comments out) all data points outside %%@
min max in column  col of
                       file file (remember to store your full data set in some other
		       file before using this command), \# is used to comment lines
\item[\prg rotate\index{rotate} xcol ycol angle file:]
program rotate  used to rotate coordinate axes,
 xcol,yxol=columns containing x and y , 
 angle=angle $\alpha$ of rotation around z.
 
 The rotation is done using the following formula:
\begin{eqnarray}
 x'&= &\cos(\alpha)*x+\sin(\alpha)*y \nonumber \\
 y'&=&-\sin(\alpha)*x+\cos(\alpha)*y
\end{eqnarray}
\item [\prg rpvalue\index{rpvalue} colx coly  *.*:]  program rpvalue\index{rpvalue}  used to %%@
calculate 
                       the $R_p$-value from columns number colx and coly 
		       in a file *.*. The $R_p$-value is defined as
		       \begin{equation}
		       R_p= 100*\frac{\sum_{i=1}^{N} |(x(i)-y(i)|}{\sum_{i=1}^{N}|x(i)|}
		       \end{equation}
                       $N$ denotes the number of data points in the file.
\item [\prg setvalue\index{setvalue} row column text files:] sets the numerical value in a specified position of a data file.

\begin{verbatim}
     row         : row number
     column    : column number
     number   : text to be placed in file at this position
     files         : one or more filenames

    example: $0 4 5 3.142 data.dat
             replaces the number in row 4 and column 5 by 3.142 in file data.dat
\end{verbatim}
\item [\prg shiftcol\index{shiftcol} col const *.*:] used to add a constant (const) to a column %%@
(number col) in file(s) *.*
\item [\prg sincol\index{sincol} col const file:] calculates sinus of a column sin(col) 
\item [\prg sumcol\index{sumcol} col *.*] prints to stdout number of lines, sum of squares, sum %%@
of absolute values of column col in file *.*
\item [\prg swapcol\index{swapcol} colx coly file:] swaps column x and column y of file
\item [\prg tancol\index{tancol} col file:] calculates tangens of a column tan(col)
\item [\prg tanhcol\index{tanhcol} col file:] calculates tangens-hyperbolicus of a column tanh(col)
\item [\prg uvw2fwhm\index{uvw2fwhm} u v w col *.*:] used to calculate the full
                   width half maximum from
                   2theta in degree according to fullprofs u,v,w parameters ...
                  The column col in file *.* must contain 2theta scattering angle
                 values and is overwritten with the fwhm as calculated by
                  \begin{equation}
                     {\rm  fwhm }= \sqrt {u \tan^2(\theta) + v \tan(\theta) + w}
                \end{equation}
\item [\prg zshift\index{zshift} constx colx coly *.*:] shifts colx by a constant such that it %%@
is zero at a specified value constx of colx. 
\end{description}

\section{Programs of General Interest}

\begin{description}
\item [\prg beep\index{beep}:] just make a beep\index{beep} to signal attention 
\item [\prg gauss\index{gauss} fwhm stp min max:] calculate a gaussian, output goes to console %%@
(stdout), the formula for a gaussian is:
$\sigma={\rm fwhm}/\sqrt{8*log(2)}$,
${\rm gauss}(x)=\frac{exp(-x^2/2 \sigma^2)}{\sqrt{2*\pi}\sigma}$
\item [\prg gauss2d\index{gauss2d} fwhm1 fwhm2 theta  stpx minx maxx stpy miny maxy:] calculate a 2 dimensional gaussian, output goes to console %%@
(stdout), the formula for a two dimensional gaussian is:
$\sigma={\rm fwhm}/\sqrt{8*log(2)}$,
${\rm gauss}(x,y)=\frac{exp(-u_1^2/2 \sigma_1^2)}{\sqrt{2*\pi}\sigma_1}\frac{exp(-u_2^2/2 \sigma_2^2)}{\sqrt{2*\pi}\sigma_2}$ with $u_1=x cos(\theta)-ysin(\theta)$ and $u_2=y cos(\theta)+xsin(\theta)$,
$\theta$ is the rotation angle in degree.
\item [\prg lorentz\index{lorentz} fwhm stp min max:] calculate a lorentzian, output goes to %%@
console (stdout)the formula for a Lorentz curve is: 
${\rm lorentz}(x)=\frac{1.0}{\pi{\rm fwhm}(1.0+x^2/fwhm^2)}$
\item [\prg plotbook *.ps:] program plotbook to arrange many (single side) ps-images to one %%@
booklet (needs: latex, pstops,ghostscript, perl)
\item [\prg script2html\index{script2html} calc1.bat calc2.bat ...] This program creates a html file from scripts containing just the text
 in the scripts.
\begin{verbatim}
 input: calc1.bat, calc2.bat ...    scripts (bat files)
                                   (must be located in the current directory)
 output: stdout      ...........   html file created from the scripts
                                   (use ">" to pipe into file)
 example:

 script2html calc.bat notes.txt > report.html

 [creates the html file report.html from files calc.bat and notes.txt]
\end{verbatim}
\item [\prg setvariable\index{setvariable} varname value *.*:]
sets a variable in a file, e.g. {\prg setvariable T 20 Co.sipf} replaces
T=15 by T=20 in file {\prg Co.sipf}.
\item [\prg substitute\index{substitute} oldtext newtext *.*:] replaces every instance of %%@
oldtext with newtext in file(s) *.*
\end{description}


