\section{Single Ion Modules}\label{simod}

In table~\ref{simodtable} the different single ion modules are listed
together with the standard operator sequence $I_a,I_b,I_c ...$.

Usually, internal single ion modules are used as a starting point.
Alternatively, the single ion properties can be calculated by a program
module which has to be written in {\prg c}. Details about this can be found 
in chapter \ref{extsimod}. Several external modules are supplied also
with the program package.

\begin{table}[htb] 
\begin{center}  
\caption {Single ion\index{singleion} modules and standard operator sequence $I_a,I_b,I_c ...$.}   
\label{simodtable}   
\begin{tabular} 
{l|l} 
module       &$I_a,I_b,I_c ...$\\
\hline
INTERNAL MODULES  & \\
\hline
{\prg so1ion}                & $J_a,J_b,J_c,O_2^{-2},O_2^{-1},O_2^{0},O_2^{1},O_2^{2},O_3^{-3}...O_6^{6}$ \\
{\prg cfield}                & $J_c,J_a,J_b,O_2^{-2},O_2^{-1},O_2^{0},O_2^{1},O_2^{2},O_3^{-3}...O_6^{6}$ \\
\hline
{\prg kramer} & $J_a,J_b,J_c$ \\
\hline
{\prg brillouin} & $J_a,J_b,J_c$\\
\hline
\hline
EXTERNAL MODULES & \\
\hline
{\prg examples/cecu2a/1ion\_mod/kramer.so}  &  $J_a,J_b,J_c$ \\
\hline
{\prg examples/dyni2b2c/1ion\_mod/quartett.so}  &  $J_a,J_b,J_c$\\
\hline
{\prg examples/erni2b2c/1ion\_mod/quartett.so}  &  $J_a,J_b,J_c$\\
\hline
{\prg examples/gdni2b2c/1ion\_mod/brillouin.so}  &  $J_a,J_b,J_c$ \\
\hline
{\prg examples/ndcu2b\_1dim/1ion\_mod/kramer.so}  & $J_a,J_b,J_c$ \\
\hline
{\prg ic1ion} & $S_a,L_a,S_b,L_b,S_c,L_c,T_2^{-2},T_2^{-1},T_2^{0},T_2^{1},T_2^{2},T_3^{-3}...T_6^{6}$\\
{\prg icf1ion} & $S_a,L_a,S_b,L_b,S_c,L_c,T_2^{-2},T_2^{-1},T_2^{0},T_2^{1},T_2^{2},T_3^{-3}...T_6^{6}$\\
\hline
{\prg bin/cf1ion\_module/cfield.so} & $J_a,J_b,J_c,O_2^{-2},O_2^{-1},O_2^{0},O_2^{1},O_2^{2},O_4^{-4}...,O_4^{4},O_6^{-6}...O_6^{6}$\\
 \end{tabular}
\end{center}   
\end{table}

The filename given for each atom in {\prg mcphas.j\index{mcphas.j}}
or {\prg mcdiff.in\index{mcdiff.in}} determines, which single ion module 
is to be used for a specific ion in the calculation.
As internal single ion modules there are currently available an isotropic spin (internal module {\prg brillouin}, %%@
see
appendix ~\ref{brillouin}), an 
 anisotropic doublet (internal module {\prg kramers}, see appendix ~\ref{kramers}), 
and the rare earth crystal field (internal module {\prg so1ion\index{so1ion}} and
cfield, see section~\ref{cfield}).

\vspace{0.5cm} 
{\bf Internal Single Ion Property Modules:} 
\begin{quote}
\item[{\prg brillouin}]
If the internal module {\prg brillouin}
 (Brillouin function used for single ion properties,
  see appendix ~\ref{brillouin}) is used,
the single ion property file must start with
\begin{verbatim}#!MODULE=brillouin\end{verbatim} and
the corresponding spin
 quantum number $J$ has to be given in the first uncommented
lines.
Here is an example:
\begin{verbatim}
#!MODULE=brillouin
#<!--mcphas.sipf-->
# single ion parameter file for Gd
J = 3.5
\end{verbatim}
\item [{\prg kramer}] If the internal module {\prg kramers} (anisotropic doublet ground state, see appendix %%@
~\ref{kramers}) is used,
the single ion property file must start with
\begin{verbatim}#!MODULE=kramer\end{verbatim} and
the corresponding saturation magnetisations have to be given in the first uncommented
line.
Here is an example:
\begin{verbatim}
#!MODULE=kramer
#<!--mcphas.sipf-->
# single ion parameter file for CeCu2
paramnames= |<+|Ja|->| |<-|Jb|->| |<+|Jc|->|
params= 1.6 0.58333   1.1
\end{verbatim}
\item[{\prg so1ion\index{so1ion}}]In order to use the rare earth crystal field module the first line should read
\begin{verbatim}#!MODULE=so1ion\end{verbatim}

then the ion name should be given followed by a list of nonzero crystal field parameters
(for a more detailed description of this module refer to section~\ref{cfield}).

\begin{verbatim}
#!MODULE=so1ion
#<!--mcphase.sipf-->
 IONTYPE=Ce3+
 B20=  0.1e-1                                           
 B22  =  -0.3e-1                                       
 B40  =  0.0
 B42  =  0.0
 B44  =  0.0
 B60  =  0.0
 B62  =  0.0
 B64  =  0.0
 B66  =  0.0
\end{verbatim}

The standard operator sequence of this module can be modified by enabling 
perl parsing\index{perl parsing}
of the sipf file, i.e. putting instead of ''IONTYPE='' a line ''\#!perl with IONTYPE=''.
Then (i) all variables have to be given in perl notation, i.e. putting a ''\$'' sign
in front of the variable name. (ii) all lines (except comment lines starting with
'\#') and variable declarations have to end with ';'. In the following example
we show how to redefine operator $\hat I_1$ (by default the x component of the
total angular momentum $\hat J_x$ to $\hat I_1 \equiv 5 \hat O_4^4 + O_4^0$.
Moreover, one of the RIXS operator is (re)defined, which enables to specify 
the appropriate tensor (note, that this will be only effective, if all the variables
SIGMA0r,SIGMA0i,SIGMA1r,SIGMA1i,SIGMA2r,SIGMA2i are zero).

\begin{verbatim}
#!MODULE=so1ion
#<!--mcphase.sipf-->
#!perl with IONTYPE=Ce3+
 $B20=  0.1e-1;                                       
 $B22  =  -0.3e-1;
 $B40  =  0.0;
 $B42  =  0.0;
 $B44  =  0.0;
 $B60  =  0.0;
 $B62  =  0.0;
 $B64  =  0.0;
 $B66  =  0.0;
 $I1 = 5.0 * $O44 + $O40; # for quadrupolar interactions

# for anisotropic Resonant Inelastic X-ray Scattering
$sigma1_a2u=1.423;
$R12=-2* $sigma1_a2u * $Jz;
# Note: Operators which may be redefined here are denoted by the variables:
# I1 I2 I3 ....
# Jx Jy Jz
# Jx2 Jy2 Jz2  (=Jx*Jx Jy*Jy Jz*Jz)
# O22S O21S O20 O21 O22 O31S .... O66
\end{verbatim}



\end{quote}

In addition to the basic parameters described above the single ion property file 
may/should contain additional parameters as described below. 

\subsection{Land\'e Factor}

In order to calculate the magnetisation and Zeeman term, the Land\'e factor
has to be entered in the single ion property file. For a rare earth ion this
factor gives the ratio of negative angular momentum / magnetic moment.
Note, for intermediate coupling schemes this factor has no meaning (should be set to zero).

\begin{verbatim}
#Lande Factor
GJ=0.85714
\end{verbatim}


\subsection{Magnetic Formfactor Coefficients}

For the more accurate calculation of neutron intensities it is
necessary to give the magnetic form factor (see the table in appendix~\ref{ffacts})
in the single ion property input file. This can
easily be don by adding some additional lines to a single ion property file:

{\footnotesize
\begin{verbatim}
#--------------------------------------------------------------------------------------
# Neutron Magnetic Form Factor coefficients - thanks to J Brown
#   d = 2*pi/Q      
#   s = 1/2/d = Q/4/pi   
#   sin(theta) = lambda * s
#   r= s*s = Q*Q/16/pi/pi
#
#   <j0(Qr)>=   FFj0A*EXP(-FFj0a*r) + FFj0B*EXP(-FFj0b*r) + FFj0C*EXP(-FFj0c*r) + FFj0D
#   <j2(Qr)>=r*(FFj2A*EXP(-FFj2a*r) + FFj2B*EXP(-FFj2b*r) + FFj2C*EXP(-FFj2c*r) + FFj2D
#   <j4(Qr)>=r*(FFj4A*EXP(-FFj4a*r) + FFj4B*EXP(-FFj4b*r) + FFj4C*EXP(-FFj4c*r) + FFj4D
#   <j6(Qr)>=r*(FFj6A*EXP(-FFj6a*r) + FFj6B*EXP(-FFj6b*r) + FFj6C*EXP(-FFj6c*r) + FFj6D
#
#   Dipole Approximation for Neutron Magnetic Formfactor:
#        -Spin Form Factor       FS(Q)=<j0(Q)>
#        -Angular Form Factor    FL(Q)=<j0(Q)>+<j2(Q)>
#        -Rare Earth Form Factor F(Q) =<j0(Q)>+<j2(Q)>*(2/gJ-1)

#--------------------------------------------------------------------------------------
FFj0A=0.0540 FFj0a=25.0293 FFj0B=0.3101 FFj0b=12.1020 FFj0C=0.6575 FFj0c=4.7223 FFj0D=-0.0216
FFj2A=0.6751 FFj2a=18.3421 FFj2B=1.6272 FFj2b=7.2600 FFj2C=0.9644 FFj2c=2.6016 FFj2D=0.0150
FFj4A=-0.4053 FFj4a=+14.0141 FFj4B=+0.0329 FFj4b=+7.0046 FFj4C=+0.3759 FFj4c=+1.7074 FFj4D=+0.0209
FFj6A=-0.0416 FFj6a=+8.0136 FFj6B=-0.1261 FFj6b=+4.0399 FFj6C=+0.1400 FFj6c=+1.0873 FFj6D=+0.0102
\end{verbatim}
}
In order to go beyond the dipolar approximation for the magnetic formfactor in case
of rare earth ions and using module {\prg so1ion} the coefficients $Z(K')$ have to
be given (see appendix~\ref{zk} for values):
{\footnotesize
\begin{verbatim}
#----------------------------------------------------------------------
# coefficients of Z(K') according to Lovesey (Neutron Scattering) vol.2
# chapter 11.6.1 page 233
#  ... these coefficients are needed to go beyond dipolar approx.
#      for the neutron magnetic formfactor in rare earth ions
#----------------------------------------------------------------------
Z1c0=+1.63636364  Z1c2=+2.95041322
		  Z3c2=-0.20896503  Z3c4=-0.25329095
				    Z5c4=+0.03820789  Z5c6=+0.14258681
						      Z7c6=-0.00614959
\end{verbatim}
}

\subsection{Debye Waller Factor}

For the more accurate calculation of neutron intensities it is
necessary to give the magnetic form factor (see the table in appendix~\ref{ffacts})
and the Debye Waller Factor in the single ion property input file. This can
easily be don by adding some additional lines to a single ion property file:
{\footnotesize
\begin{verbatim}
#-------------------------------------------------------
# Debye-Waller Factor: sqr(Intensity)~|sf|~EXP(-2 * DWF *s*s)=EXP (-W)
#                      with s=sin(theta)/lambda=Q/4pi
# relation to other notations: 2*DWF=Biso=8 pi^2 <u^2>
# unit of DWF is [A^2]
#-------------------------------------------------------
DWF=0.4
\end{verbatim}
}

\subsection{Nuclear Neutron Scattering Length}

In order to calculate nuclear neutron intensities properly, {\prg mcdiff} has to
be provided with the neutron scattering length in units of $10^{-14}$~m.
{\footnotesize
\begin{verbatim}
#-------------------------------------------------------
# Neutron Scattering Length (10^-12 cm) (can be complex)
#-------------------------------------------------------
SCATTERINGLENGTHREAL=0.769
SCATTERINGLENGTHIMAG=0
#  ... note: - if an occupancy other than 1.0 is needed, just reduce 
#              the scattering length linear accordingly
\end{verbatim}
}

\subsection{Radial Wavefunction}

In order to calculate the charge density correctly (programs {\prg charges, chrgplt}) and
to evaluate the pointcharge model (program {\prg pointc}) the radial wave function has to be entered in the %%@
parametrization of Clementi and Roetti:
{\footnotesize
\begin{verbatim}
#------------------------------------------------------------------------------------------------------
# radial wave function parameters R_Np,XIp(r)= r^(Np-1) . exp(-xi r) . (2 XIp)^(Np+0.5) / sqrt(2Np!)  
# values tabulated in clementi & roetti Atomic data and nuclear data tables 14 (1974) 177-478
# Co2+ is isoelectronic to Fe+, looking at page  422 of Clemente & Roetti 
# the 3D radial wave function is expanded as R(r)=sum_p C_p R_Np,XIp(r)
#------------------------------------------------------------------------------------------------------
N1=3 XI1=4.95296 C1=0.36301 
N2=3 XI2=12.2963 C2=0.02707 
N3=3 XI3=7.03565 C3=0.14777
N4=3 XI4=2.74850 C4=0.49771 
N5=3 XI5=1.69027 C5=0.11388 
\end{verbatim}
}

The radial wavefunction may be calculated numerically using the program {\prg radwavfunc}\index{radwavfunc}.

\subsection{Radial Matrix Elements}

For the program {\prg pointc} alternatively, the radial matrix elements can be given:
{\footnotesize
\begin{verbatim}
#---------------------------------------------------------
# Radial Matrix Elements (e.g. Abragam Bleaney 1971 p 399)
#---------------------------------------------------------
#<r^2> in units of a0^2 a0=0.5292 Angstroem
R2=1.114
#<r^4> in units of a0^4 a0=0.5292 Angstroem
R4=2.91
#<r^6> in units of a0^6 a0=0.5292 Angstroem
R6=15.03
\end{verbatim}
}



\section{All about Programming External Single Ion Modules}\label{extsimod}

Single ion properties can be described in a very flexible way by
user programmed single ion module functions, which are loaded at runtime.

The first line in such a single ion property file
must contain the filename of the loadable module, in the following example
the file {\prg ./1ion\_mod/kramer.so}:

\begin{verbatim}
#!./1ion_mod/kramer.so
#<!--mcphas.sipf-->
# single ion parameter file for CeCu2
# there follow some module parameters (up to 9) which are 
# loaded at initialisation of the module
nof_electrons=1
MODPAR1=1.6
MODPAR2=0.58333
MODPAR3=1.1

...
\end{verbatim}


If the first line refers not to an internal module, but to
 a loadable module file, the single ion
properties are calculated using functions in this module file.

In the following sections the different functions are presented
which need to be present in the loadable module in order to 
run the programs. All functions have to be present, but only 
formally. If a function is not implemented please just let
print out a message and exit. The corresponding programs
will not work then. Table~\ref{modulefunctions} lists all
functions which can be implemented in a loadable module.
There are two groups of functions: (i) basic module functions, which
provide the information about the interaction operators $\hat \mbf I$
and their transition matrix elements. These are used to solve the
meanfield Hamiltonian and calculate the excitation energies (using the DMD method).
(ii) module functions for observables - these are used to generate
output for different observables, such as neutron cross sections, 
magnetic moments, chargedensities etc.


\begin{table}[htb] 
\begin{center}  
\caption {External Single ion\index{singleion} module functions in the context of the {\prg McPhase}
programs.}   
\label{modulefunctions}   
\begin{tabular} 
{l|l|l|l} 
Module - Function       & obligatory for & optional for & description \\  
\hline
\hline
Basic Functions         && & \\
\hline
\hline
void Icalc              & {\prg mcphas}         & &calculates $\langle \hat \mbf I \rangle$\\
						& {\prg singleion}      &&\\
{\tiny Icalc\_parameter\_storage\_matrix\_init}  && {\prg mcphas}       &parameter storage for Icalc,mcalc etc\\
   {\tiny (void)}                     && {\prg mcdiff}         &\\
						&& {\prg singleion}     &\\
						&& {\prg spins}        &\\
						&& {\prg densplt}        &\\
\hline
int du1calc				& {\prg mcdisp} &&calculates $\langle -|\hat \mbf I|+\rangle\sqrt{(p_--p_+)}$\\
						&& {\prg singleion}     &\\	
void estates            &&	{\prg mcdiff}         & parameter storage for du1calc,dm1,dS1,...\\
						&& {\prg singleion}     &\\	
						&& {\prg mcdisp} &\\
\hline
Observables & &&\\
\hline
\hline
void mcalc      	& & {\prg mcdiff} & magnetic moment $\langle\hat \mbf M\rangle$\\
	                & & {\prg mcphase} &\\
int dm1		& & {\prg mcdisp} & $\langle-| \hat\mbf M|+\rangle\sqrt{(p_--p_+)}$\\
\hline
void Lcalc      	& & {\prg mcdiff} & orbital ang. momentum $\langle \mbf L\rangle$\\
	                & & {\prg mcphase} &\\
int dL1		& & {\prg mcdisp} & $\langle-| \hat\mbf L|+\rangle\sqrt{(p_--p_+)}$\\
\hline
void Scalc      	& & {\prg mcdiff} & spin $\langle \hat\mbf S\rangle$\\
	                & & {\prg mcphase} &\\
int dS1		& & {\prg mcdisp} &  $\langle-|\hat \mbf S|+\rangle\sqrt{(p_--p_+)}$\\
\hline
void mqcalc      	& & {\prg mcdiff} & FT of magnetic moment $\langle\hat \mbf M(\mbf Q)\rangle$\\
int dmq1		& & {\prg mcdisp} &  $\langle-|\hat \mbf M(\mbf Q)|+\rangle\sqrt{(p_--p_+)}$\\
\hline
int drixs1 & & {\prg mcdisp} & RIXS transition operator $\hat \mbf R$,eq. (\ref{rixsop})\\
\hline
void chargedensity\_coeff  & {\prg densplt -c}&&coeff of $-|e|Z_l^m(\Omega)R^2(r)$ in equ.(\ref{chargedensity2})\\
&{\prg spins -c} & & i.e. $\langle\sum_i Z_l^m(\Omega_i)\rangle$\\
                        &{\prg display\_density -c}&&\\
                        &{\prg display\_densities -c}&&\\
int dchargedensity\_coeff1 & & {\prg mcdisp} &  $\langle-|\sum_i Z_l^m(\Omega_i)|+\rangle\sqrt{(p_--p_+)}$\\
\hline
void spindensity\_coeff  &-''- -s&&coeff of $Z_l^m(\Omega)R^2(r)$\\
int dspindensity\_coeff1 & & {\prg mcdisp} &  \\
\hline
void orbmomdensity\_coeff  & -''- -m$|$-o$|$-j&&coeff of $Z_l^m(\Omega)F(r)$\\
int dorbmomdensity\_coeff1 & & {\prg mcdisp} & \\
\hline
double ro\_calc && {\prg densplt -c}& chargedensity (instead of expansion coeff)\\			
                 &       &{\prg spins -c}& - will always be used if present\\
                 &       &{\prg display\_density -c}&\\
                 &       &{\prg display\_densities -c}&\\
 \end{tabular}
\end{center}   
\end{table}
 
\clearpage

Note, in case of non-orthogonal axes the convention for the components
of the external applied field $\mbf H$, the mean field, the magnetic moment 
components, the polarisation vectors etc. to be adopted in programming a single ion module is
 $H_2||\vec b$, $H_3||(\vec a \times \vec b)$ and $H_1$ perpendicular to $H_2$ and $H_3$
(here $\vec a$,$\vec b$,$\vec c$ denote the lattice vectors of the crystal structure
as specified by the lattice constants $a,b,c$ and the angles $\alpha,\beta,\gamma$
 in {\prg mcphas.j}).



\subsection{Basic Module Functions}


%*************************************************************************************
\subsubsection{External module function {\prg Icalc} - used by {\prg mcphas},
{\prg singleion\index{singleion}} }

In order to run {\prg mcphas},{\prg singleion\index{singleion}}
 the following function has to be present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void Icalc(Vector & I,double * T, Vector & Hxc, Vector & Hext,
                      double * gJ, Vector & MODPAR,
                      char ** sipffilename, double * lnZ,double * U,
                      ComplexMatrix & Icalc_parstorage);
\end{verbatim}

Note for windows users with MINGW the declaration should be {\prg extern "C" \_\_declspec(dllexport) void %%@
Icalc(...)}.

The meaning of the symbols is as follows:
{\footnotesize
\begin{verbatim}
  on input
    T           temperature[K]
    Hxc         vector of exchange field [meV] (n-dimensional, for a set of n operators I)
    Hext        external magnetic field [T] (3 components)
    gJ          Lande factor as read from sipf file
    MODPAR      Vector with Parameters  read from single ion property file
    sipffilename    file name of the single ion parameter file
    Icalc_parstorage parameter matrix (initialized by Icalc_parameter_storage_matrix_init)
                   it should/may contain any information, e.g. population numbers of the
                   states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
                   for this ion (use of this matrix is optional, it is provided to save time by
                   storing here information instead of recalculating it for every call of Icalc)
  on output    
    I           thermal expectation value of operator <I> (n- dimensional with n>=1,
                may be an arbitrary set of operators,
    lnZ         natural logarithm of single ion partition function
    U           single ion magnetic energy [meV]
    Icalc_parstorage     parameter matrix matrix (optional)
                   it should/may contain any information for the next call of Icalc, e.g.
                   population numbers of the states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) ...
\end{verbatim}
}
The module function must perform the following tasks:
\begin{enumerate}
\item check if the dimensions of vectors ${\mbf I}$,Hxc (taken by {\prg mcphas} from the number of 
interaction constant columns in {\prg mcphas.j\index{mcphas.j}})
 and MODPAR (taken by {\prg mcphas} from the number of params in the single ion property
file) agree with the module specifications. Note a module may be designed to 
take different dimensions depending on the input files, however the dimensions
of vectors  ${\mbf I}$ and Hxc has to agree and must be within the range of dimensions which
can be treated by the module. If the check fails the module function should exit the
program with an appropriate error message
\item the module should calculate from external field $\mbf H_{ext}$ at a given temperature the 
thermal expectation values of the operators $\langle Ia\rangle, \langle Ib\rangle,\langle Ic\rangle etc$ 
and return them as
a vector $\mbf I$. Input file parameters params are supplied as a vector MODPAR and
Lande factor as gJ and  can be used for this purpose. The Hamiltonian
is usually assumed to be of the general form
 $H=H_0- \mbf M \mbf H_{ext} - I_a {\rm Hxc}(1) -I_b {\rm Hxc}(2) -I_c {\rm Hxc}(3) 
-I_d {\rm Hxc}(4) ...$.
\item the natural logarithm of the partition sum Z should be calculated and returned as lnZ,
$Z=\sum_i e^{-E_i/kT}$
\item the magnetic energy U should be calculated and returned as U, $U=\sum_i p_i=\sum_i E_i e^{-E_i/kT}/Z$
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

... as an example the anisotropic doublet function is given as a
loadable module in the file {\prg ./examples/cecu2a/1ion\_mod/kramer.c}, in the same
directory a Makefile is given in order to show how this loadable
module is compiled (for details see appendix~\ref{kramers}).

Another more complicated example, the calculation of the magnetisation
in a tetragonal quasi-quartet system is given in Appendix~\ref{dyni2b2c}.

%*************************************************************************************
\subsubsection{External module function {\prg Icalc\_parameter\_storage\_matrix\_init} - used by {\prg %%@
mcphas\index{mcphas}},{\prg singleion\index{singleion}},{\prg spins\index{spins}} and {\prg %%@
densplt\index{densplt}},{\prg mcdiff\index{mcdiff}}  }

This routine is optional, i.e. it may be programmed, but is not absolutely necessary.
Before any call to Icalc this function will be called. subsequent calls to Icalc will provide this matrix to %%@
Icalc, Icalc may set values to this matrix to be read in the next call
of Icalc.

This feature provides the designer of a single ion module  with the possiblity to store information for subsquent %%@
calls of Icalc,
 usually the eigenvalues and eigenstates of a problem. This can be very useful to accelerate computations. For %%@
example, in {\prg mcphas} meanfield iterations require
to solve a similar eigenvalue problem in each iteration step. Therefore the {\prg mcphas} module provides
to the single ion module on every call to the function {\prg Icalc} the parmeter matrix {\prg }
which the module stored in its last call for a specfic ion in the magnetic unit cell.

At the start of the programs {\prg mcphas} {\prg mcdiff} {\prg singleion} the function {\prg %%@
Icalc\_parameter\_storage\_matrix\_init}
is called (if present in the module) and it should initialize a Complex Matrix by a command such as

{\prg (*parstorage)=ComplexMatrix(0,nofrows,1,nofcols);}

and fill this matrix with sensible numerical values, in particular for the effective field, temperature given at %%@
the input of this function.
Parameters {\prg MODPAR} and Lande Factor {\prg gJ} may be used for this purpose.

The routine should look similar to
{\footnotesize
\begin{verbatim}
#include "vector.h"          // MatPack vector class must be included

#ifdef __linux__
extern "C" void Icalc_parameter_storage_matrix_init(
#else
extern "C" __declspec(dllexport) void Icalc_parameter_storage_matrix_init(
#endif
// on output
                     ComplexMatrix * parstorage,    // storage matrix
// on input
                       Hxc ,                 //   vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
                       Hext,                 // external magnetic field [T]
                      double *g_J,           // Input Lande g-factor
                      double &T,             // Input temperature (K)
                      Vector &MODPAR,     // Input vector of parameters 
                                          //from single ion property file
                      char **sipffilename)// Single ion properties filename
{ // ... some code to compute eigenvectors and eigenvalues

// dimension matrix
(*parstorage)=ComplexMatrix(0,nofrows,1,nofcols);

// fill matrix with values
int l,m;
          for(l=1;l<=nofrows;++l)for(m=1;m<=nofcols;++m)
          {(*parstorage)(l,m)=complex <double> ( 4 , 2);}
                 // instead of 4 and 2 put the real 
                 //and imaginary parts to be stored
}
\end{verbatim}
}


%*************************************************************************************
\subsubsection{External module function {\prg du1calc} - used by {\prg mcdisp\index{mcdisp}},{\prg %%@
singleion\index{singleion}}}

The external single ion module has to provide the components nofcomponentsxnofcomponents
matrix $M^s_{\alpha\beta}$ (see equation (\ref{mmatrix})) for every transition
$|-\rangle \rightarrow |+\rangle$which is to be taken into consideration 
in the calculation. Note, in general$M^s_{\alpha\beta}$ it is a quadratic matrix with the same
dimension as the vectors $\mbf I$ and Hxc. 
Actually it is not necessary to compute the whole  Matrix $M^s_{\alpha\beta}$, because
only the first eigenvector is needed in the computations.
Thus, in order to make calculations easier and provide a unique phase of the eigenvectors, the 
external single ion module must return not the Matrix $M$ but the unnormalized
eigenvector $u1$, which is given by equation (\ref{ufirstrow}):
 ${\mbf u^s_{\alpha1}}=\sqrt{(p_--p_+)}\langle -|I^s_{\alpha}-\langle I^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$. 
Note that in contrast to ${\mathcal U^s_{\alpha1}}$ the eigenvector
${\mbf u^s_{\alpha1}}$ is not normalised (no $\gamma$!)
and thus the matrix  $M^s_{\alpha\beta}$ may be recovered from it.

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int du1calc(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & u1,float & delta, ComplexMatrix & est)
\end{verbatim}

The meaning of the symbols is as follows:

\begin{verbatim}
on input
   |tn|            transition-number  
   sign(tn)        >0 standard, <0 routine should do some printout to stdout for user information
   MODPAR          Vector with Parameters  read in single ion property file
   sipffilename    file name of the single ion parameter file
   g_J             Lande factor
   T               Temperature[K]
   Hxc             vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
   Hext            external magnetic field [T]
   est             eigenstate matrix (initialized by estates)
                   it should/may also contain population numbers of the states
				   (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
				   for this ion (use of this matrix is optional)
   u1(1)           ninit + i pinit (from mcdisp options  -ninit and -pinit)
   delta           upper boundary for transition energy (meV) to be considered
                   (from mcdisp option -maxE)
on output
   int             total number of transitions
   delta           transition energy [meV]
   u1             vector u1=<-|Ialpha-<Ialpha>|+>sqrt((p- - p+))                          
                note that as in Icalc the single ion momentum vector <-|I|+> 
				(n- dimensional with n>=1)
                may be an arbitrary set of operators
\end{verbatim}
}
The module function must perform the following tasks:
\begin{enumerate}
\item check if the dimensions of vectors I,Hxc (taken by {\prg mcphas} from the number of 
interaction constant columns in {\prg mcphas.j\index{mcphas.j}})
 and MODPAR (taken by {\prg mcphas} from the number of params in the single ion property
file) agree with the module specifications. Note a module may be designed to 
take different dimensions depending on the input files, however the dimensions
of vectors I and Hxc has to agree and must be within the range of dimensions which
can be treated by the module. If the check fails the module function should exit the
program with an appropriate error message
\item the module function should do a numbering of all possible single ion transitions and return
the total number of transitions as an integer. Input file parameters params are supplied as a vector MODPAR and
Lande factor as g\_J and  can be used for this purpose. The numbering will depend on
the parameters ninit, pinit and maxE which are provided as input. These parameters
have to be considered. {\em IMPORTANT: the numbering scheme of transitions has to
be the same for du1calc and all the corresponding d...1 functions for observables !}
\item it should calculate from meanfields at a given temperature the 
transition energy of transition number {\prg tn}. The result should be returned as {\prg delta}
\item for the transition number tn the vector u1 is to
 be filled with 
${\mbf u^s_{\alpha1}}=\sqrt{(p_--p_+)}\langle -|I^s_{\alpha}-\langle I^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$.
\item
If the energy of this transition
is zero, i.e. $\Delta(tn)=0$ (diffuse scattering), 
the expression (\ref{mmatrix}) would be zero because $(p_--p_+)$ vanishes.
In this case the single ion module should calculate $(p_+/kT)$ instead of $(p_--p_+)$.
\item if transition is from a level to itself, then a negative 
value of $\Delta=-10^{-10}$ should be returned.
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

%*************************************************************************************
\subsubsection{External module function {\prg estates} - used by {\prg mcdisp\index{mcdisp}},
 {\prg %%@
mcdiff\index{mcdiff}} and {\prg singleion\index{singleion}}}

This routine is optional, i.e. may be programed but is not absolutely necessary. It provides the designer of a %%@
single ion module
with the possiblity to store information, usually the eigenvalues and eigenstates of a problem. This can be very %%@
useful to accelerate computations. 
For example, the module {\prg mcdisp} provides to the single ion module functions
 {\prg du1calc} and {\prg dMQ1} and similar
at every call the matrix {\prg estates} which has been set initially for every atom
by a call to {\prg estates}.

At the start of the programs {\prg mcdisp} {\prg singleion} the function {\prg estates}
is called (if present in the module) and it should initialize the Complex Matrix by a command such as

{\prg (*ests)=ComplexMatrix(0,nofrows,1,nofcols);} 

and fill this matrix with sensible numerical values for the effective field, temperature given.
Parameters {\prg MODPAR} and Lande Factor {\prg gJ} may be used for this purpose. 

The routine should look similar to
{\footnotesize
\begin{verbatim}
#include "vector.h"          // MatPack vector class must be included

#ifdef __linux__
extern "C" void estates(
#else
extern "C" __declspec(dllexport) void estates(
#endif
// on output
                     ComplexMatrix * ests,    // eigenstate matrix      
                                              // it must also contain population 
                                              // numbers p_i of the states (imaginary part of row 0)
                                              // and eigenvalues (real part of row 0)
// on input
                      Hxc ,                 //   vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
                      Hext  ,                     // external magnetic field [T]
                      double *g_J,        // Input Lande g-factor
                      double &T,          // Input temperature (K)
                      Vector &MODPAR,     // Input vector of parameters from 
					                      //single ion property file
                      char **sipffilename)// Single ion properties filename                      
{ // ... some code to compute eigenvectors and eigenvalues

 dj=21;  // dimension matrix according to the  dimension of your eigenvalue problem
   (*ests) = ComplexMatrix(0,dj,1,dj);
   Vector En(1,dj),pn(1,dj);Matrix zr(1,dj,1,dj);Matrix zi(1,dj,1,dj);
   setup_and_solve_Hamiltonian(Hxc,Hext,En,zr,zi,sort); // call some function to solve your Hamiltonian
   
   for(i=1;i<=dj;++i)for(j=1;j<=dj;++j)(*ests)(i,j)=complex <double> (zr(i,j),zi(i,j));   // fill matrix with eigenstates
 
    //calculate partition sum and Boltzmann probabilities pn
    double zz;calculate_Z_pn(En,T,zz,pn);

     // put Energies and Boltzmann population into row 0 of eigenstates...
     for(j=1;j<=dj;++j){(*eigenstates)(0,j)=complex<double>(En(j),pn(j));}

}
\end{verbatim}
Note: if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
}



\subsection{Module Functions for Observables}


%*************************************************************************************
\subsubsection{External module function {\prg mcalc} - used by {\prg mcdiff\index{mcdiff}}
and {\prg mcphas}\index{mcphas}  }

In order to calculate magnetic moments
 the following function has to be present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void mcalc(Vector & m,double * T, Vector & Hxc, Vector & Hext,
                      double * gJ, Vector & MODPAR,
                      char ** sipffilename, ComplexMatrix & Icalc_parstorage);
\end{verbatim}

Note for windows users with MINGW the declaration
 should be {\prg extern "C" \_\_declspec(dllexport) void mcalc(...)}.

The meaning of the symbols is as follows:
{\footnotesize
\begin{verbatim}
  on input
    T           temperature[K]
    Hxc         vector of exchange field [meV] (n-dimensional, for a set of n operators I)
    Hext        external magnetic field [T] (3 components)
    gJ          Lande factor as read from sipf file
    MODPAR      Vector with Parameters  read from single ion property file
    sipffilename    file name of the single ion parameter file
    Icalc_parstorage parameter matrix (initialized by Icalc_parameter_storage_matrix_init)
                   it should/may contain any information, e.g. population numbers of the
                   states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
                   for this ion (use of this matrix is optional, it is provided to save time by
                   storing here information instead of recalculating it for every call of Icalc)
  on output    
    m             =<2S+L>, thermal expectation value of the magnetic moment operator <m> 
                  in units of muB
    Icalc_parstorage     parameter matrix matrix (optional)
                   it should/may contain any information for the next call of mcalc/Icalc, e.g.
                   population numbers of the states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) ...
\end{verbatim}
}
The module function must perform the following tasks:
\begin{enumerate}
\item check if the dimensions of vector Hxc (taken by {\prg mcphas} from the number of 
interaction constant columns in {\prg mcphas.j\index{mcphas.j}})
 and MODPAR (taken by {\prg mcphas} from the number of params in the single ion property
file) agree with the module specifications.  If the check fails the module function should exit the
program with an appropriate error message
\item the module should calculate from external field $\mbf H_{ext}$ at a given temperature the 
thermal expectation values of the three components of the magnetic moment
and return them as
a vector $\mbf m$. Input file parameters params are supplied as a vector MODPAR and
Lande factor as gJ and  can be used for this purpose. The Hamiltonian
is usually assumed to be of the general form
 $H=H_0- \mbf M \mbf H_ext - I_a {\rm Hxc}(1) -I_b {\rm Hxc}(2) -I_c {\rm Hxc}(3) 
-I_d {\rm Hxc}(4) ...$.
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

Thus the function resembles closely Icalc, however no U and lnZ are calculated and
the magnetic moment vector m, which is returned, has always exactly 3 components.


%*************************************************************************************
\subsubsection{External module function {\prg dm1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualized magnetic moment fluctuations and to calculate neutron intensities
in dipole approximation the external single ion module has to provide the transition
matrix elements of the magnetic moment operator in units of $\mu_B$ by the
vector $m1$, which is given by:
 ${\rm m1}^s_{\alpha}=\sqrt{(p_--p_+)}\langle -|m^s_{\alpha}-\langle m^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dm1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & m1,float & maxE, ComplexMatrix & est)
\end{verbatim}

The meaning of the symbols is as follows:

\begin{verbatim}
on input
   |tn|            transition-number  
   sign(tn)        >0 standard, <0 routine should do some printout to stdout for user information
   MODPAR          Vector with Parameters  read in single ion property file
   sipffilename    file name of the single ion parameter file
   g_J             Lande factor
   T               Temperature[K]
   Hxc             vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
   Hext            external magnetic field [T]
   est             eigenstate matrix (initialized by estates)
                   it should/may also contain population numbers of the states
				   (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
				   for this ion (use of this matrix is optional)
   u1(1)           ninit + i pinit (from mcdisp options  -ninit and -pinit)
   maxE            upper boundary for transition energy (meV) to be considered
                   (from mcdisp option -maxE)
on output
   int             total number of transitions
   u1             transition matrix element vector m1=<-|m-<m>|+>sqrt((n- - n+))                          
\end{verbatim}
}
The module function must perform the following tasks:
\begin{enumerate}
\item check if the dimensions of vector Hxc (taken by {\prg mcphas} from the number of 
interaction constant columns in {\prg mcphas.j\index{mcphas.j}})
 and MODPAR (taken by {\prg mcphas} from the number of params in the single ion property
file) agree with the module specifications. If the check fails the module function should exit the
program with an appropriate error message
\item the module function should do a numbering of all possible single ion transitions and return
the total number of transitions as an integer. Input file parameters params are supplied as a vector MODPAR and
Lande factor as g\_J and  can be used for this purpose. The numbering will depend on
the parameters ninit, pinit and maxE which are provided as input. These parameters
have to be considered. {\em IMPORTANT: the numbering scheme of transitions has to
be the same for du1calc and all the corresponding d...1 functions for observables !}
\item for the transition number tn the vector m1 is to
 be filled with 
${\mbf m1^s_{\alpha}}=\sqrt{(p_--p_+)}\langle -|m^s_{\alpha}-\langle m^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$.
(note $\mbf m=2\mbf S+ \mbf L $).
\item
If the energy of this transition
is zero, i.e. $\Delta(tn)=0$ (diffuse scattering), 
the expression (\ref{mmatrix}) would be zero because $(p_--p_+)$ vanishes.
In this case the single ion module should calculate $(p_+/kT)$ instead of $(p_--p_+)$.
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}


%*************************************************************************************
\subsubsection{External module function {\prg Lcalc} - used by {\prg mcdiff\index{mcdiff}}
and {\prg mcphas}\index{mcphas}  }

In order to calculate the angular momentum $\langle \hat \mbf L \rangle$
 the following function has to be present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void Lcalc(Vector & L,double * T, Vector & Hxc, Vector & Hext,
                      double * gJ, Vector & MODPAR,
                      char ** sipffilename, ComplexMatrix & Icalc_parstorage);
\end{verbatim}

it works exactly as {\prg mcalc}, therefore we do not give more details here.


%*************************************************************************************
\subsubsection{External module function {\prg dL1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualize angular momentum fluctuations and to calculate neutron intensities
in dipole approximation the external single ion module has to provide the transition
matrix elements of the angular momentum by the
vector $L1$, which is given by:
 ${\rm L1}^s_{\alpha}=\sqrt{(p_--p_+)}\langle -|L^s_{\alpha}-\langle L^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dL1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & L1,float & maxE, ComplexMatrix & est)
\end{verbatim}
}
The meaning of the symbols follows exactly that of function 
{\prg dm1} and therefore not explained here.

%*************************************************************************************
\subsubsection{External module function {\prg Scalc} - used by {\prg mcdiff\index{mcdiff}}
and {\prg mcphas}\index{mcphas}  }

In order to calculate the total spin $\langle \hat \mbf S \rangle$
 the following function has to be present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void Scalc(Vector & S,double * T, Vector & Hxc, Vector & Hext,
                      double * gJ, Vector & MODPAR,
                      char ** sipffilename, ComplexMatrix & Icalc_parstorage);
\end{verbatim}

it works exactly as {\prg mcalc}, therefore we do not give more details here.


%*************************************************************************************
\subsubsection{External module function {\prg dS1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualize spin fluctuations and to calculate neutron intensities
in dipole approximation the external single ion module has to provide the transition
matrix elements of the spin by the
vector $S1$, which is given by:
 ${\rm S1}^s_{\alpha}=\sqrt{(p_--p_+)}\langle -|S^s_{\alpha}-\langle S^s_{\alpha}\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dS1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & S1,float & maxE, ComplexMatrix & est)
\end{verbatim}
}
The meaning of the symbols follows exactly that of function 
{\prg dm1} and therefore not explained here.


%*************************************************************************************
\subsubsection{External module function {\prg mqcalc} - used by {\prg mcdiff\index{mcdiff}}  }

 ''going beyond''  dipolar approximation is a desirable feature of an accurate
 calculation of magnetic neutron scattering intensity and can be performed using
 mcphase. The internal module {\prg so1ion}\index{so1ion} does this in an excellent
 way for the ground state multiplet of rare earth atoms (see section \ref{mcdiff_gobeyond})
 using equations (\ref{scattoperator}) for the scattering operator $\hat \mathcal Q$.
 A more general formula for this scattering operator operator relates this operator
 to the Fourier transform of the magnetisation density $\mbf M(\mbf r)$of the unfilled shell of a specific
 ion~\cite{lovesey84-1}:
 
 \begin{equation}\label{scattop}
 \hat  \mbf Q \times (\hat \mathcal Q \times \hat \mbf  Q) = \frac{-1}{2\mu_B} 
 \hat  \mbf Q \times (\mbf M(\mbf Q) \times \hat \mbf  Q) =\frac{-1}{2\mu_B} \int d\mbf r
    \hat  \mbf Q \times (\mbf M(\mbf r) \times \hat \mbf  Q)
 \end{equation}
 
 Note that the magnetisation density consists of two contributions $\mbf M(\mbf r)=\mbf M_S(\mbf r)+\mbf M_L(\mbf %%@
r)$, the
 spin and orbital contribution. The orbital contribution is not uniquely defined due to a gauge freedom ($\nabla %%@
\times \mbf M_L (\mbf r)=\mbf j(\mbf r)$, the curl of the magnetisation must give the current density, so any %%@
gradient of a potential may be added
to $\mbf M(\mbf r)$ without changing the result). However, this does not matter, because adding a gradient of a %%@
potential
to $\mbf M(\mbf r)$ will just give a contribution $\mbf Q \times \mbf Q \times \mbf Q=0$ to the equation %%@
(\ref{scattop}),
thus the neutron scattering cross section is not sensitive to the chosen gauge, which is an important feature of %%@
the theory.
 
 
Technically,  ''going beyond''  dipolar approximation in the program {\prg mcdiff\index{mcdiff}}
can be done with  module functions {\prg mq} and {\prg estates}. 
The output of {\prg mq} is the Fourier transform of the magnetization
density in units of $\mu_B$, which is equivalent to two times the scattering operator 
 $\langle \hat \mathcal Q^{d \dag}_{\alpha} \rangle_{T,H}$ for
 a given orientation of the scattering vector. {\prg mq} is called many times, for
 every scattering vector. In order to
 do an efficient calculation the eigenstates should be calculated only
 once, this is the task of function {\prg estates}.


The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" void mqcalc(ComplexVector & mq,double & th,double & ph,double J0,
double & J2, double & J4, double & J6,ComplexMatrix & est)
\end{verbatim}

The meaning of the symbols is as follows:

\begin{verbatim}
on input
   th     polar angle theta of the scattering vector Q (angle with the axb axis=c axis) in rad
   ph     polar angle phi of the scattering vector Q (angle with bx(axb)=a in the 
          projection into the  bx(axb),b plane = angle with a in the projection into the 
		  ab plane) in rad
   J0,J2,J4,J6     form factor functions <jn(Q)>   
   est             eigenstate matrix (as calculated by estates),
                   it should also contain population numbers of the states
on output
   mq(1..3)        Kartesian components of the scattering operator mq=<M(Q)>/muB=-2<Q>_TH
                    Note that: 
                               mq(1)=<Mbx(axb)(Q)>/muB
                               mq(2)=<Mb(Q)>/muB
                               mq(3)=<Maxb(Q)>/muB
                    according to Lovesey Neutron Scattering equation 6.87b the 
                    scattering operator is given in  spherical coordinates 
					Q-1,Q0,Q+1 (introduced as described above on input of th and ph)
					these are related to cartesion coordinates by 11.123
				    thus at Q=0  <M(Q)>=2<S>+<L>

\end{verbatim}
}

%*************************************************************************************

\subsubsection{External module functions {\prg dmq1} - used by {\prg mcdisp\index{mcdisp}}  }

Similarly  ''going beyond''  dipolar approximation in the program {\prg mcdisp\index{mcdisp}}
can be done with  module functions {\prg dmq1} and {\prg estates}. 
The input of {\prg dmq1} 
has similar arguments as
{\prg du1calc}, but as additional argument an orientation
of the scattering vector,
output should be a corresponding vector
 ${\mbf m^s_{\alpha1}}(\mbf Q)=\sqrt{(p_--p_+)}
\langle -|\hat \mbf M_{\alpha}^{\dag}(\mbf Q)-\langle \hat \mbf M_{\alpha}^{\dag}(\mbf Q)\rangle|+\rangle/\mu_B$.
Here $\mathcal Q_{\alpha}=\frac{ \mbf M_{\alpha}(\mbf Q)}{-2 \mu_B}$
 are the cartesian components of the scattering operator.
 {\prg dmq1} is called many times, for
 every scattering vector. In order to
 do an efficient calculation the eigenstates should be calculated only
 once, this is the task of function {\prg estates} (see above).


The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dmq1(int & tn,double & th,double & ph,double J0,
double & J2, double & J4, double & J6,ComplexMatrix & est,double & T,
ComplexVector & mq1, float & maxE)
\end{verbatim}

The meaning of the symbols is as follows:

\begin{verbatim}
on input
   |tn|            transition-number  
   sign(tn)        >0 standard with printouts for user information, 
                   <0 routine should omit any printout
   th              polar angle theta of the scattering vector Q 
                   (angle with the axb axis=c axis) in rad
   ph              polar angle phi of the scattering vector Q 
                   (angle with bx(axb)=a in the projection into
                   the  bx(axb),b plane = angle with a in the projection into 
				   the ab plane) in rad
   J0,J2,J4,J6     form factor functions <jn(Q)>   
   est             eigenstate matrix (as calculated by estates),
                   it should also contain population numbers of the states (row 0)
   T               Temperature[K]
   mq1(1)           ninit + i pinit (from mcdisp options  -ninit and -pinit)
   maxE            maximum transition energy (from mcdisp option maxE)
on output
   int             total number of transitions
   mq1             vector mq(alpha)=<-|-2Qalpha|+>sqrt(p- - p+)
                   
     Note on Qalpha
        Cartesian components of the scattering operator Qalpha, alpha=1,2,3=a,b,c
        according to Lovesey Neutron Scattering equation 6.87b 
        scattering operator is given in  spherical coordinates Q-1,Q0,Q+1 (introduced
        as described above on input of th and ph) these are related to euclidean 
		components by 11.123
        Q1=Qbx(axb)
        Q2=Qb                         
        Q3=Qaxb    
                   
        the orbital and spin contributions can be given as separate 
		components  according to Lovesey Neutron Scattering 
		equations 11.55 and 11.71 (the spin part 11.71 has to be
        divided by 2), i.e.
        <-|QSa,b,c|+>=
          =<-|sum_i exp(i k ri) s_(a,b,c)|+> /2                   as defined by 11.71 / 2
				   
        <-|QLa,b,c|+>=
          =<-|sum_i exp(i k ri) (-(k x grad_i)_(a,b,c)/|k|)|+>     as defined by 11.54 /(-|k|)
	     thus for k=0 <QS>=<S>/2 and <QL>=<L>/2 
        Q=2QS+QL, M(Q)=Q/(-2muB)=mq1/muB
				
\end{verbatim}
}

The module function must perform the following tasks:
\begin{enumerate}
\item for the transition number tn the vector mq1  is to be filled with the 3-components 
of ${\mbf m^s_{\alpha1}}(\mbf Q)=\sqrt{(p_--p_+)}
\langle -|\hat \mbf M_{\alpha}^{\dag}(\mbf Q)-\langle \hat \mbf M_{\alpha}^{\dag}(\mbf Q)\rangle|+\rangle/\mu_B$.
, i.e. for $\alpha=1,..3$ 
{\em IMPORTANT: the numbering scheme of transitions has to
be the same for du1calc and all the corresponding d...1 functions for observables !}
\item
If the energy of this transition
is zero, i.e. $\Delta(tn)=0$ (diffuse scattering), 
the ${\mbf m^s_{\alpha1}}(\mbf Q)$ 
 would be zero because $(p_--p_+)$ vanishes (compare expression (\ref{mmatrix})).
In this case the single ion module should calculate $(p_+/kT)$ instead of $(p_--p_+)$.
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

%************************************************************************************************

\subsubsection{External module functions {\prg drixs1} - used by {\prg mcdisp\index{mcdisp}}  }
Very similar to the inelastic neutron scattering (module function {\prg dmq1})
the Resonant inelastic X-ray scattering cross sections in the program {\prg mcdisp\index{mcdisp}}
can be done with  module functions {\prg drixs1} and {\prg estates}. 
The input of {\prg drixs1} 
has similar arguments as
{\prg du1calc}, but as additional argument an orientation
of the scattering vector,
output should be a corresponding vector
 ${{\mbf r\mbf i\mbf x\mbf s}^s_{\alpha1}}(\mbf Q)=\sqrt{(p_--p_+)}
\langle -|\hat \mbf R_{\alpha}^{\dag}(\mbf Q)-\langle \hat \mbf R_{\alpha}^{\dag}(\mbf Q)\rangle|+\rangle$.
Here $\hat R_{\alpha}$ with $\alpha= xx, xy ,xz, yx, yy, yz, zx,zy, zz$ are the 9 
  components of the RIXS scattering operator, see equ (\ref{rixsop}).
 {\prg drixs1} is called many times, for
 every scattering vector. In order to
 do an efficient calculation the eigenstates should be calculated only
 once, this is the task of function {\prg estates} (see above).

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int drixs1(int & tn,double & th,double & ph,double J0,
double & J2, double & J4, double & J6,ComplexMatrix & est,double & T,
ComplexVector & rixs, float & maxE)
\end{verbatim}

The meaning of the symbols is as follows:

\begin{verbatim}
on input
   |tn|            transition-number  
   sign(tn)        >0 standard with printouts for user information, 
                   <0 routine should omit any printout
   th              polar angle theta of the scattering vector Q 
                   (angle with the axb axis=c axis) in rad
   ph              polar angle phi of the scattering vector Q 
                   (angle with bx(axb)=a in the projection into
                   the  bx(axb),b plane = angle with a in the projection into 
				   the ab plane) in rad
   J0,J2,J4,J6     form factor functions <jn(Q)>   
   est             eigenstate matrix (as calculated by estates),
                   it should also contain population numbers of the states (row 0)
   T               Temperature[K]
   rixs(1)           ninit + i pinit (from mcdisp options  -ninit and -pinit)
   maxE            maximum transition energy (from mcdisp option maxE)
on output
   int             total number of transitions
   rixs            vector rixs(alpha)=<-|Ralpha|+>sqrt(p- - p+) 
                   with alpha=1,..9=xx, xy ,xz, yx, yy, yz, zx,zy, zz
                   
     Note on coordinate system:
        x||bx(axb)
        y||b                         
        z||axb    
\end{verbatim}
}

The module function must perform the following tasks:
\begin{enumerate}
\item for the transition number tn the vector mq1  is to be filled with the 9-components 
of ${{\mbf r\mbf i\mbf x\mbf s}^s_{\alpha1}}(\mbf Q)=\sqrt{(p_--p_+)}
\langle -|\hat \mbf R_{\alpha}^{\dag}(\mbf Q)-\langle \hat \mbf R_{\alpha}^{\dag}(\mbf Q)\rangle|+\rangle$
, i.e. for $\alpha=1,..9$.
{\em IMPORTANT: the numbering scheme of transitions has to
be the same for du1calc and all the corresponding d...1 functions for observables !}
\item
If the energy of this transition
is zero, i.e. $\Delta(tn)=0$ (diffuse scattering), 
the ${{\mbf r\mbf i\mbf x\mbf s}^s_{\alpha1}}(\mbf Q)$ 
 would be zero because $(p_--p_+)$ vanishes (compare expression (\ref{mmatrix})).
In this case the single ion module should calculate $(p_+/kT)$ instead of $(p_--p_+)$.
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

%*************************************************************************************
\subsubsection{External module function {\prg chargedensity\_coeff} -
used by {\prg densplt\index{densplt}},
{\prg spins\index{spins}},
{\prg display\_density\index{display\_density}},{\prg display\_densities\index{display\_densities}}}

In order to calculate the chargedensity, the expansion coefficients
have to be evaluated and
 the following function has to be present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void chargedensity_coeff(Vector & cd,double * T, Vector & Hxc, Vector & Hext,
                      double * gJ, Vector & MODPAR,
                      char ** sipffilename, ComplexMatrix & Icalc_parstorage);
\end{verbatim}

it works exactly as {\prg mcalc} with the only modification
that the vector cd has 28 components, therefore we do not give more details here.

The module function must perform the following task:
\begin{enumerate}
\item calculate the coefficients of $-|e|Z_l^m R^2(r)$ in the expansion of
      the charge density in equation (\ref{chargedensity2}).
      The output Vector cd(1,\dots,28) should contain  coefficients 
     (i.e. $\langle\sum_i Z_l^m (\Omega_i)\rangle$)
      in the following order (lm):  00, 2-2, 2-1,20,21,22, 4-4, 4-3,..,44,6-6,6-5 ...,65,66
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}


%*************************************************************************************
\subsubsection{External module function {\prg dchargedensity\_coeff1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualize charge density  fluctuations 
 the external single ion module has to provide the transition
matrix elements of the chargedensity coefficient operator $\sum_i Z_{lm}(\Omega_i)$ by a
vector $cd1$, which is given by:
 ${\rm cd1}^s_{\alpha=lm}=\sqrt{(p_--p_+)}\langle -|\sum_i Z^s_{lm}(\Omega_i)-\langle \sum_i Z^s_{lm}(\Omega_i)\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dchargedensity_ceoff1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & cd1,float & maxE, ComplexMatrix & est)
\end{verbatim}
}
The meaning of the symbols follows exactly that of function 
{\prg dm1} and therefore not explained here.


%*************************************************************************************
\subsubsection{External module function {\prg spindensity\_coeff} -
used by {\prg densplt\index{densplt}},
{\prg spins\index{spins}},
{\prg display\_density\index{display\_density}},{\prg display\_densities\index{display\_densities}}}

In order to calculate spindensities
the following function has to be
present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void spindensity_coeff(Vector &aSlm, int & xyz, double *T,Vector &Hxc, 
   Vector & Hext,double *gJ,Vector &MODPAR,char **sipffilename,ComplexMatrix & Icalc_parstorage);
\end{verbatim}

Note for windows users with MINGW the declaration should be {\prg extern "C" \_\_declspec(dllexport) void %%@
spindensity\_coeff(...)}.

The meaning of the symbols is as follows:
{\footnotesize
\begin{verbatim}
  on input
    xyz         direction index 1,2,3 = x,y,z (component for the spindensity vector to be calculated)
    T           temperature[K]
    Hxc        vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
     Hext      external magnetic field [T]
    gJ          Lande factor
    MODPAR      Vector with Parameters  read in single ion property file
    sipffilename    file name of the single ion parameter file
    Icalc_parstorage parameter matrix (initialized by Icalc_parameter_storage_matrix_init)
                   it should/may contain any information, e.g. population numbers of the
				   states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
                   for this ion (making use of this matrix is optional)
  on output
    aSlm         Output single ion moments =expectation values of
                coefficients of Zlm R^2(r) at a given temperature T and
                effective field H
\end{verbatim}
}

The module function must perform the following tasks:
\begin{enumerate}
\item calculate the coefficients of $Z_l^m R^2(r)$ in the expansion of
      the spin density vector $M^S_{x,y,z}=\sum_{l,m} a^{x,y,z}_{S,lm} Z_l^m R^2(r)$
      The output Vector alm(1,\dots,49) should contain  $a^{x,y,z}_{S,lm}$
      in the following order (lm):  00,1-1, 10,11, 2-2, 2-1,20,21,22, 3-3, 3-2, ...,65,66
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

%*************************************************************************************
\subsubsection{External module function {\prg dspindensity\_coeff1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualize spin density  fluctuations 
 the external single ion module has to provide the transition
matrix elements of the spindensity coefficient operator $a^{x,y,z}_{S,lm}$ by a
vector $aSlm1$, which is given by:
 ${\rm aS1}^s_{\alpha=lm}=\sqrt{(p_--p_+)}\langle -|a^{x,y,z}_{S,lm}-\langle a^{x,y,z}_{S,lm}\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dspindensity_ceoff1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & aSlm1,float & maxE, ComplexMatrix & est)
\end{verbatim}
}
The meaning of the symbols follows exactly that of function 
{\prg dm1} and therefore not explained here.


%*************************************************************************************
\subsubsection{External module function {\prg orbmomdensity\_coeff} -
used by {\prg densplt\index{densplt}},
{\prg spins\index{spins}},
{\prg display\_density\index{display\_density}},{\prg display\_densities\index{display\_densities}}}


In order to calculate orbital moment densities
the following function has to be
present in the module file {\prg *.so}:

\begin{verbatim}
extern "C" void orbmomdensity_coeff(Vector &aLlm, int & xyz, double *T,Vector &Hxc, 
   Vector & Hext,double *gJ,Vector &MODPAR,char **sipffilename,ComplexMatrix & Icalc_parstorage);
\end{verbatim}

Note for windows users with MINGW the declaration should be {\prg extern "C" \_\_declspec(dllexport) void %%@
orbmomdensity\_coeff(...)}.

The meaning of the symbols is as follows:
{\footnotesize
\begin{verbatim}
  on input
    xyz         direction index 1,2,3 = x,y,z (component for the spindensity vector to be calculated)
    T           temperature[K]
    Hxc         vector of exchange field [meV] (can be n-dimensional, for a set of n operators)
    Hext        external magnetic field [T]
    gJ          Lande factor
    MODPAR      Vector with Parameters  read in single ion property file
    sipffilename    file name of the single ion parameter file
    Icalc_parstorage parameter matrix (initialized by Icalc_parameter_storage_matrix_init)
                   it should/may contain any information, e.g. population numbers of the
				   states (imaginary part of row 0)
                   and eigenvalues (real part of row 0) with values set by the most recent call
                   for this ion (use of this matrix is optional)
  on output
    aLlm         Output single ion moments =expectation values of
                coefficients of Zlm F(r) at a given temperature T and
                effective field H
\end{verbatim}
}

The module function must perform the following tasks:
\begin{enumerate}
\item calculate the coefficients of $Z_l^m F(r)$ in the expansion of
      the orbital moment
      density vector $M^L_{x,y,z}=\sum_{l,m} a^{x,y,z}_{L,lm} Z_l^m F(r)$
      The output Vector alm(1,\dots,49) should contain  $a^{x,y,z}_{L,lm}$
      in the following order (lm):  00,1-1, 10,11, 2-2, 2-1,20,21,22, 3-3, 3-2, ...,65,66
\item if $T<0$ all quantities should be evaluated assuming that all Boltzmann probabilities $p_i$
 are zero except for the state number $n=(-T)$, for which the probability $p_n=1$.
\end{enumerate}

Note the definition of $F(r)$ in terms of the radial wave function $R(r)$ is

\begin{equation}
F(r)=\frac{1}{r}\int_r^{\infty} R^2(\xi)d\xi
\end{equation}

%*************************************************************************************
\subsubsection{External module function {\prg dorbmomdensity\_coeff1} - used by {\prg mcdisp\index{mcdisp}}}

In order to visualize orbital moment density  fluctuations 
 the external single ion module has to provide the transition
matrix elements of the spindensity coefficient operator $a^{x,y,z}_{L,lm}$ by a
vector $aSlm1$, which is given by:
 ${\rm aL1}^s_{\alpha=lm}=\sqrt{(p_--p_+)}\langle -|a^{x,y,z}_{L,lm}-\langle a^{x,y,z}_{L,lm}\rangle_{\mbf H,T}|+\rangle$. 

The format to be used is:
{\footnotesize
\begin{verbatim}
extern "C" int dspindensity_ceoff1(int & tn,double & T,Vector & Hxc,Vector & Hext,double * g_J,Vector & MODPAR,
char ** sipffilename,ComplexVector & aLlm1,float & maxE, ComplexMatrix & est)
\end{verbatim}
}
The meaning of the symbols follows exactly that of function 
{\prg dm1} and therefore not explained here.


%*************************************************************************************
\subsubsection{External module function {\prg ro\_calc} -
used by {\prg chrgplt\index{chrgplt}},
{\prg charges\index{charges}}
}

In order to calculate more complex charge densities, the optional function
{\prg rocalc} may be present in the module file {\prg *.so}. If present,
it will be used by programs {\prg chrgplt\index{chrgplt}},
{\prg charges\index{charges}}:

\begin{verbatim}
extern "C" double ro_calc(double & teta,double & fi,double &R,Vector &aLlm,  double *gJ,Vector &MODPAR,char **sipffilename);
\end{verbatim}

Note for windows users with MINGW the declaration should be {\prg extern "C" \_\_declspec(dllexport) double %%@
ro\_calc(...)}.

The meaning of the symbols is as follows:
{\footnotesize
\begin{verbatim}
  on input
    teta, fi, R(Angsgtroem) .... spatial position in spherical coordinates
    gJ          Lande factor
    MODPAR      Vector with Parameters  read in single ion property file
    sipffilename    file name of the single ion parameter file
    aLlm          single ion moments =expectation values of
                coefficients of Zlm F(r) at a given temperature T and
                effective field H
on output
  double ro_rocalc ... the charge density
\end{verbatim}
}

The module function must perform the following tasks:
\begin{enumerate}
\item calculate the charge density for plotting
\end{enumerate}


