/*****************************************************************/
// functions for programs charges, spindensity, orbmomdensity momdensity
//                        currdensities
/*****************************************************************/
void print_mcdiff_in_header(FILE * fout)
{
fprintf(fout,"\
#\n\
#<!--mcdiff.mcdiff.in>\n\
#***************************************************************\n\
#      mcdiff is a program for the calculation of elastic\n\
#   neutron diffraction and resonant magnetic Xray scattering\n\
#  reference: M. Rotter and A. Boothroyd PRB 79 (2009) 140405R\n\
#***************************************************************\n\
# this input file contains 4 sections corresponding to different\n\
# groups of parameters\n\
#\n\
# - all lines have to start with a # sign with the  exception of\n\
#   the lines containing atomic positional parameters\n\
# - the other parameters have to be defined in the corresponding\n\
#   section by statements such as parameter=value\n\
# - the sequence of the parameters within a section is arbitrary\n\
#\n\
#\n\
# %%SECTION 1%%  OVERALL PARAMETERS\n\
#\n\
#! lambda   = 2.3587  wavelength (A)\n\
#\n\
#! thetamax = 10   maximum bragg angle (deg)\n\
#\n\
#! ovalltemp= 0  overall temperature factor (A^2)\n\
#           ...I ~ EXP(-2 * ovalltemp * sintheta^2 / lambda^2)\n\
#                  relation to other notations:\n\
#                  ovalltemp = Biso = 8 pi^2 Uiso^2\n\
#\n\
#! lorentz=0  type of lorentzfactor to be used\n\
#            0.....no lorentzfactor \n\
#            1.....neutron powder flat sample\n\
#            2.....neutron powder cylindrical sample\n\
#            3.....neutron single crystal\n\
#            4.....neutron TOF powder cyl. sample - d-pattern log scaled\n\
#            5.....neutron TOF powder cyl. sample - d-pattern normal scaled\n\
#\n\
#     out* controls the type of output in user defined column * of mcdiff.out\n\
#! out4=30    (optional)\n\
#! out5=31    (optional)\n\
#! out6=32    (optional)\n\
#! out10=1    (optional)\n\
#! out11=0    (optional)\n\
#     ... in out*=n the numbers n have the following meaning:\n\
#            0....LF          \n\
#            1....|NSF|[b]    \n\
#            2....Re(NSF)[b]  \n\
#            3....Im(NSF)[b]  \n\
#            4....|MSF|       \n\
#            5....|MSF.P|     \n\
#            6....Re(MSF.P)   \n\
#            7....Im(MSF.P)   \n\
#            8....|MSFdip|    \n\
#            9....|MSFdip.P|  \n\
#            10....Re(MSFdip.P)\n\
#            11....Im(MSFdip.P)\n\
#            12....angl(Q,P)[deg]\n\
#            13....i(MSFxMSF*).P\n\
#            14....I+          \n\
#            15....I-          \n\
#            16....I+/I-       \n\
#            17....i(MSFxMSF*)dip.P\n\
#            18....Idip+       \n\
#            19....Idip-       \n\
#            20....Idip+/Idip- \n\
#            21....2*|MSF.P|/sin^2(angl(Q,P))\n\
#            22....2*|MSFdip.P|/sin^2(angl(Q,P))\n\
#            23....2|NSF|sqrt(4PI/3.65)(|g|-sqrt(g^2-1/sin(angl(Q,P))))_with_g=(1+I+/I-)/(1-I+/I-)\n\
#            24....2|NSF|sqrt(4PI/3.65)(|g|+sqrt(g^2-1/sin(angl(Q,P))))_with_g=(1+I+/I-)/(1-I+/I-)\n\
#            25....2|NSF|sqrt(4PI/3.65)(|g|-sqrt(g^2-1/sin(angl(Q,P))))_with_g=(1+Idip+/Idip-)/(1-Idip+/Idip-)\n\
#            26....2|NSF|sqrt(4PI/3.65)(|g|+sqrt(g^2-1/sin(angl(Q,P))))_with_g=(1+Idip+/Idip-)/(1-Idip+/Idip-)\n\
#            27....Qx[1/A]     \n\
#            28....Qy[1/A]     \n\
#            29....Qz[1/A]     \n\
#            30....d[A]        \n\
#            31....|Q|[1/A]    \n\
#            32....2theta      \n\
#\n\
#           In the above the intensities I+ and I- are the intensities in apolarised neutron experiment\n\
#           with incident polarisation up (+) or down (-):\n\
#            I+-=LF exp(-OTF Q^2/8pi^2) \n\
#                    [ |NSF/NB|^2 + 3.65/4pi (|MSF|^2-+i(MSF x MSF*).P)/NB^2 \n\
#                        +-  sqrt(3.65/4pi)/NB^2 (NSF (MSF*.P) + NSF* (MSF.P)]\n\
#           LF  ..... Lorentzfactor\n\
#           MSF ..... magnetic structure factor\n\
#           NSF ..... nuclear structure factor\n\
#\n\
#\n\
#             For some of the above options we need the\n\
#! Pa=  0.0000   Components of Polarisation Vector in terms of lattice vectors P=(Pa * a + Pb * b + Pc *c)\n\
#! Pb=  0.0000   Note: the length of P, i.e. |P| indicates the degree of beam polarisation (|P|<=1)\n\
#! Pc=  1.0000\n\
#\n\
#\n\
#\n\
# %%SECTION 2%% LIST OF NONMAGNETIC ATOMS IN CRYSTALLOGRAPHIC UNIT CELL\n\
#\n\
# !!!  NONMAGNETIC ATOMS HAVE NOT BEEN GENERATED BY setup_mcdiff_in !!!\n\
#\n\
#! natcryst=0      number of nonmagnetic atoms in primitive crystalographic unit cell\n\
#\n\
# it follows a list of natcryst lines with nonmagnetic atoms\n\
# ... notes: - if an occupancy other than 1.0 is needed, just reduce\n\
#              the scattering length linear accordingly\n\
#            - Debye Waller Factor notation: sqr(Intensity) ~ structure factor ~\n\
#              ~sum_n ()n exp(-2 DWFn sin^2(theta) / lambda^2)=EXP (-Wn),\n\
#              relation to other notations: 2*DWF = B = 8 pi^2 <u^2>, units DWF (A^2)\n\
#\n\
#! use_dadbdc=0\n\
#            - 0 means: da db and dc are not used by the program (unless you enter a line #! use_dadbdc=1),\n\
#               dr1,dr2 and dr3 refer to the primitive lattice given below\n\
#\n\
# Real Imag[scattering length(10^-12cm)]   da(a)    db(b)    dc(c)    dr1(r1)  dr2(r2)  dr3(r3)  DWF(A^2)\n\
#   0.73250   0.00000                       -1.43200 -1.43200  0.71600  0.00000 -0.71600  1.43200  0.00000\n\
#   0.73250   0.00000                       -2.56800 -2.56800  1.28400  0.00000 -1.28400  2.56800  0.00000\n\
#\n\
#\n\
# %%SECTION 3%% DESCRIPTION OF THE LATTICE\n\
#\n\
# -----------------------------------------------------------------------------\n");

}
void check_for_best(FILE *fin_coq,double Tin, double hain,double hbin, double hcin, spincf & savmf, double & T,Vector & Hext,char*outstr)
{// load mfconfigurations and check which one is nearest -------------------------------

int n;
   double ddT,ddHa,ddHb,ddHc,dd,delta;
 float numbers[13];numbers[9]=1;numbers[10]=3;
 numbers[0]=13;char instr[MAXNOFCHARINLINE];
 long int pos=0;
 if(Tin>=0)
{
 for (delta=1000.0;feof(fin_coq)==0                      //end of file
                    &&(n=inputline(fin_coq,numbers))>=8   //error in line reading (8 old format, 9 new format)
		    ;)

    { spincf spins(1,1,1,(int)numbers[9],(int)numbers[10]);
      spins.load(fin_coq);
     if(Tin==0){ddT=0; // here hain and hbin correspond to x and y in phasediagram
                ddHa=hain-numbers[1];ddHa*=ddHa;
                ddHb=hbin-numbers[2];ddHb*=ddHb;
                ddHc=0;
      } else {
      ddT=Tin-numbers[3];ddT*=ddT;
      ddHa=hain-numbers[5];ddHa*=ddHa;
      ddHb=hbin-numbers[6];ddHb*=ddHb;
      ddHc=hcin-numbers[7];ddHc*=ddHc;
      }
      dd=sqrt(ddT+ddHa+ddHb+ddHc+0.000001);
      if (dd<delta)
       {delta=dd;
        sprintf(outstr,"x=%g y=%g T=%g Ha=%g Hb=%g Hc=%g n=%g spins nofatoms=%i in primitive basis nofcomponents=%i",myround(numbers[1]),myround(numbers[2]),myround(numbers[3]),myround(numbers[5]),myround(numbers[6]),myround(numbers[7]),myround(numbers[8]),(int)numbers[9],(int)numbers[10]);
        savmf=spins;T=numbers[3];Hext(1)=numbers[5];Hext(2)=numbers[6];Hext(3)=numbers[7];
       }
      pos=ftell(fin_coq); 
                 fgets(instr,MAXNOFCHARINLINE,fin_coq); 
                 while (instr[strspn(instr," \t")]=='#'&&feof(fin_coq)==0) // pointer to 'ltrimstring' 
                  {pos=ftell(fin_coq);fgets(instr,MAXNOFCHARINLINE,fin_coq);}
       fseek(fin_coq,pos,SEEK_SET);
    }
 } 
   else
 {// look for config number -Tin
  for(n=1;n<=-Tin;++n)
  {if(savmf.load(fin_coq)==0){fprintf(stderr,"Error program spins: loading configuration number %i\n",n);exit(1); }
  }
 }
}
   
int headerinput(FILE * fin_coq,FILE* fout,graphic_parameters & gp,cryststruct & cs)
{ char instr[MAXNOFCHARINLINE];
 long int pos=0,j;int n=0;
cs.nofatoms=0;cs.nofcomponents=3;
char *token;cs.abc=0;
  instr[0]='#';
 while (instr[strspn(instr," \t")]=='#') // pointer to 'ltrimstring'
  { pos=ftell(fin_coq);
   if (pos==-1)
       {fprintf(stderr,"Error: wrong mf/sps file format\n");exit (EXIT_FAILURE);}
   fgets_errchk(instr,MAXNOFCHARINLINE,fin_coq);
   // inserted 4.4.08 in order to format output correctly (characterstring 13 spoiled output string)
   int i;
   for(i=0;(unsigned int)i<=strlen(instr);++i){if(instr[i]==13)instr[i]=32;}
   // strip /r (dos line feed) from line if necessary
    while ((token=strchr(instr,'\r'))!=NULL){*token=' ';}

   if (instr[strspn(instr," \t")]=='#'){fprintf(fout,"%s",instr);}
   if(cs.abc[1]==0){extract(instr,"a",cs.abc[1]);extract(instr,"b",cs.abc[2]); extract(instr,"c",cs.abc[3]);
                 extract(instr,"alpha",cs.abc[4]);  extract(instr,"beta",cs.abc[5]);extract(instr,"gamma",cs.abc[6]);
   }
   extract(instr,"show_abc_unitcell",gp.show_abc_unitcell);
   extract(instr,"show_primitive_crystal_unitcell",gp.show_primitive_crystal_unitcell);
   extract(instr,"show_magnetic_unitcell",gp.show_magnetic_unitcell);
   extract(instr,"show_atoms",gp.show_atoms);
   extract(instr,"spins_scale_moment",gp.spins_scale_moment);
   extract(instr,"show_chargedensity",gp.show_density);

   extract(instr,"scale_view_1",gp.scale_view_1);
   extract(instr,"scale_view_2",gp.scale_view_2);
   extract(instr,"scale_view_3",gp.scale_view_3);

   extract(instr,"r1x",cs.r[1][1]);extract(instr,"r2x",cs.r[1][2]); extract(instr,"r3x",cs.r[1][3]);
   extract(instr,"r1y",cs.r[2][1]); extract(instr,"r2y",cs.r[2][2]); extract(instr,"r3y",cs.r[2][3]);
   extract(instr,"r1z",cs.r[3][1]); extract(instr,"r2z",cs.r[3][2]); extract(instr,"r3z",cs.r[3][3]);
   extract(instr,"r1a",cs.r[1][1]);extract(instr,"r2a",cs.r[1][2]); extract(instr,"r3a",cs.r[1][3]);
   extract(instr,"r1b",cs.r[2][1]); extract(instr,"r2b",cs.r[2][2]); extract(instr,"r3b",cs.r[2][3]);
   extract(instr,"r1c",cs.r[3][1]); extract(instr,"r2c",cs.r[3][2]); extract(instr,"r3c",cs.r[3][3]);
   extract(instr,"nofatoms",cs.nofatoms);    extract(instr,"nofcomponents",cs.nofcomponents);
   if ((cs.nofatoms>0)&&((extract(instr,"x",cs.x[n+1])+
                    extract(instr,"y",cs.y[n+1])+
  		       extract(instr,"z",cs.z[n+1])==0)||
		       (extract(instr,"da",cs.x[n+1])+
                   extract(instr,"db",cs.y[n+1])+
		       extract(instr,"dc",cs.z[n+1])==0)))
		  {++n;if(n>cs.nofatoms||cs.nofatoms>cs.maxnofatoms)
                    {fprintf(stderr,"ERROR reading file:maximum number of atoms in unit cell exceeded\n");exit(EXIT_FAILURE);}
                   cs.sipffilenames[n]=new char[MAXNOFCHARINLINE];
                   extract(instr,"sipffilename",cs.sipffilenames[n],(size_t)MAXNOFCHARINLINE);
//		   printf("%s\n",cs.sipffilenames[n]);
                  }
  }
    j=fseek(fin_coq,pos,SEEK_SET);
    if (j!=0){fprintf(stderr,"Error: wrong mf file format\n");exit (EXIT_FAILURE);}
return n;
}
